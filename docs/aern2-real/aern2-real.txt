-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Exact real numbers via Cauchy sequences and MPFR
--   
--   TODO
@package aern2-real
@version 0.1.0.0


-- | Cacheable question-answer protocols
module AERN2.QA
class (Show p, Show (Q p), Show (A p)) => QAProtocol p where type Q p type A p where {
    type family Q p;
    type family A p;
}
class (QAProtocol p) => QAProtocolCacheable p where type QACache p where {
    type family QACache p;
}
newQACache :: QAProtocolCacheable p => p -> QACache p
lookupQACache :: QAProtocolCacheable p => p -> QACache p -> Q p -> Maybe (A p)
updateQACache :: QAProtocolCacheable p => p -> QACache p -> Q p -> A p -> QACache p

-- | An object we can ask queries about. Queries can be asked in some Arrow
--   <tt>to</tt>.
data QA to p
QA__ :: String -> Maybe (QAId to) -> [QAId to] -> p -> Q p -> (Q p) `to` (A p) -> QA to p
[qaName] :: QA to p -> String
[qaId] :: QA to p -> Maybe (QAId to)
[qaSources] :: QA to p -> [QAId to]
[qaProtocol] :: QA to p -> p
[qaSampleQ] :: QA to p -> Q p
[qaMakeQuery] :: QA to p -> (Q p) `to` (A p)
data AnyProtocolQA to
AnyProtocolQA :: (QA to p) -> AnyProtocolQA to

-- | Add caching to pure (-&gt;) QA objects via unsafe memoization,
--   inspired by
--   <a>https://hackage.haskell.org/package/ireal-0.2.3/docs/src/Data-Number-IReal-UnsafeMemo.html#unsafeMemo</a>,
--   which, in turn, is inspired by Lennart Augustsson's uglymemo.
addUnsafeMemoisation :: (QAProtocolCacheable p) => QA (->) p -> QA (->) p

-- | A class of Arrows suitable for use in QA objects.
class (ArrowChoice to, Eq (QAId to)) => QAArrow to where type QAId to type QAPromise to :: * -> * qaMakeQueryA = qaMakeQueryGetPromiseA >>> qaFulfilPromiseA qaMakeQueriesA = (mapA qaMakeQueryGetPromiseA) >>> (mapA qaFulfilPromiseA) newQA = defaultNewQA where {
    type family QAId to;
    type family QAPromise to :: * -> *;
}

-- | Register a QA object, which leads to a change in its query processing
--   mechanism so that, eg, answers can be cached or computations assigned
--   to different threads/processes.
--   
--   The "sources" component of the incoming QA object can be used to
--   record the dependency graph among QA objects. After registration, the
--   QA object should have its list of dependencies **empty** as the
--   registration has recorded them elsewhere.
qaRegister :: (QAArrow to, QAProtocolCacheable p) => (QA to p) `to` (QA to p)
qaMakeQueryGetPromiseA :: QAArrow to => (QA to p, Q p) `to` (QAPromise to (A p))
qaFulfilPromiseA :: QAArrow to => (QAPromise to a) `to` a
qaMakeQueryA :: QAArrow to => (QA to p, Q p) `to` (A p)
qaMakeQueriesA :: QAArrow to => [(QA to p, Q p)] `to` [A p]
newQA :: (QAArrow to, QAProtocolCacheable p) => String -> [AnyProtocolQA to] -> p -> Q p -> (Q p) `to` (A p) -> QA to p
qaMakeQueryOnManyA :: (QAArrow to) => ([QA to p], Q p) `to` [A p]
(-:-) :: (QAArrow to, QAProtocolCacheable p) => (QA to p) `to` (QA to p)
infix 0 -:-

-- | Turn a pure QA object into any QAArrow QA object.
qaArr :: (QAArrow to, QAProtocolCacheable p) => (QA (->) p) -> (QA to p)
type QACachedA = Kleisli QACachedM
data QANetInfo
QANetInfo :: Map ValueId AnyQAComputation -> QANetLog -> QANetInfo
[net_id2value] :: QANetInfo -> Map ValueId AnyQAComputation
[net_log] :: QANetInfo -> QANetLog
executeQACachedA :: (() `QACachedA` a) -> (QANetLog, a)
printQANetLogThenResult :: (Show a) => (QANetLog, a) -> IO ()
instance GHC.Show.Show AERN2.QA.QANetLogItem
instance GHC.Enum.Enum AERN2.QA.ValueId
instance GHC.Classes.Ord AERN2.QA.ValueId
instance GHC.Classes.Eq AERN2.QA.ValueId
instance GHC.Show.Show AERN2.QA.ValueId
instance AERN2.QA.QAArrow (->)
instance AERN2.QA.QAArrow AERN2.QA.QACachedA


-- | The type of Cauchy real numbers
module AERN2.Real.Type
data CauchyRealP
pCR :: CauchyRealP
type CauchyRealA to = QA to CauchyRealP
type CauchyReal = CauchyRealA (->)
newCR :: (QAArrow to) => String -> [AnyProtocolQA to] -> Accuracy `to` MPBall -> CauchyRealA to
convergentList2CauchyRealA :: (QAArrow to) => String -> [MPBall] -> (CauchyRealA to)
seqByPrecision2CauchyRealA :: (QAArrow to) => String -> (Precision -> MPBall) -> (CauchyRealA to)
type CanBeReal t = CanBeRealA (->) t
real :: (CanBeRealA (->) t) => t -> CauchyReal
type CanBeRealA to t = ConvertibleExactly t (CauchyRealA to)
realA :: (CanBeRealA to t) => t -> CauchyRealA to

-- | Given a list <tt>[(a1,b1),(a2,b2),...]</tt> and assuming that at least
--   one of <tt>a1,a2,...</tt> is non-zero, pick one of them and return the
--   corresponding pair <tt>(ai,bi)</tt>.
--   
--   If none of <tt>a1,a2,...</tt> is zero, either throw an exception or
--   loop forever.
pickNonZeroRealA :: (QAArrow to) => [(CauchyRealA to, s)] `to` (CauchyRealA to, s)
instance GHC.Show.Show AERN2.Real.Type.CauchyRealP
instance AERN2.QA.QAProtocol AERN2.Real.Type.CauchyRealP
instance AERN2.QA.QAProtocolCacheable AERN2.Real.Type.CauchyRealP
instance GHC.Show.Show AERN2.Real.Type.CauchyReal
instance Numeric.CatchingExceptions.Type.CanTestValid AERN2.Real.Type.CauchyReal
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Dyadic.Dyadic (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Real.Rational (AERN2.Real.Type.CauchyRealA to)
instance AERN2.MP.Precision.ConvertibleWithPrecision AERN2.Real.Type.CauchyReal AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.CanPickNonZero AERN2.Real.Type.CauchyReal


-- | Auxiliary functions for CR operations
module AERN2.Real.Aux
getCRFnNormLog :: (Arrow to) => CauchyRealA to -> (MPBall -> MPBall) -> Accuracy `to` (NormLog, MPBall)
binaryWithBall :: (MPBall -> MPBall -> MPBall) -> CauchyReal -> MPBall -> MPBall
unaryOp :: (QAArrow to) => String -> (CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall) -> (CauchyRealA to -> (Accuracy `to` (Accuracy, Maybe MPBall))) -> CauchyRealA to -> CauchyRealA to
binaryOp :: (QAArrow to) => String -> (CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall) -> (CauchyRealA to -> CauchyRealA to -> (Accuracy `to` ((Accuracy, Maybe MPBall), (Accuracy, Maybe MPBall)))) -> CauchyRealA to -> CauchyRealA to -> CauchyRealA to
binaryOpWithPureArg :: (QAArrow to) => String -> (CatchingNumExceptions MPBall -> t -> CatchingNumExceptions MPBall) -> (CauchyRealA to -> t -> (Accuracy `to` (Accuracy, Maybe MPBall))) -> CauchyRealA to -> t -> CauchyRealA to
getInitQ1FromSimple :: (Arrow to) => Accuracy `to` q -> r1 -> Accuracy `to` (q, Maybe MPBall)
getInitQ1TFromSimple :: (Arrow to) => Accuracy `to` q -> r1 -> t -> Accuracy `to` (q, Maybe MPBall)
getInitQ1Q2FromSimple :: (Arrow to) => Accuracy `to` (q, q) -> r1 -> r2 -> Accuracy `to` ((q, Maybe MPBall), (q, Maybe MPBall))


-- | Comparison operations on Cauchy Real numbers.
module AERN2.Real.Comparison
data CauchyBoolP
CauchyBoolP :: CauchyBoolP
type CauchyBoolA to = QA to CauchyBoolP
type CauchyBool = CauchyBoolA (->)

-- | CauchyRealAtAccuracy exists only so that we can QuickCheck that
--   CauchyReal satisfies properties whose statement relies on an instance
--   of HasEqCertainly. CauchyReal is not an instance but
--   CauchyRealAtAccuracy is.
data CauchyRealAtAccuracy
CauchyRealAtAccuracy :: CauchyReal -> Accuracy -> CauchyRealAtAccuracy
instance GHC.Show.Show AERN2.Real.Comparison.CauchyRealAtAccuracy
instance GHC.Show.Show AERN2.Real.Comparison.CauchyBoolP
instance AERN2.QA.QAProtocol AERN2.Real.Comparison.CauchyBoolP
instance AERN2.QA.QAProtocolCacheable AERN2.Real.Comparison.CauchyBoolP
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Bool (AERN2.Real.Comparison.CauchyBoolA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Bool.CanNeg (AERN2.Real.Comparison.CauchyBoolA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Bool.CanAndOrAsymmetric (AERN2.Real.Comparison.CauchyBoolA to) (AERN2.Real.Comparison.CauchyBoolA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Eq.HasEqAsymmetric (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ord.HasOrderAsymmetric (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.Real.Comparison.CauchyRealAtAccuracy AERN2.Real.Comparison.CauchyRealAtAccuracy
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.Real.Comparison.CauchyRealAtAccuracy AERN2.Real.Comparison.CauchyRealAtAccuracy
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanAbs (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Integer.Type.Integer
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Types.Int
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (AERN2.Real.Type.CauchyRealA to) AERN2.MP.Dyadic.Dyadic
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Real.Rational
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Real.Rational (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.Real.Type.CauchyReal AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.Real.Type.CauchyReal


-- | Ring operations on Cauchy Real numbers.
module AERN2.Real.Ring
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Bool.CanNeg (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Integer.Type.Integer
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Types.Int
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Real.Type.CauchyRealA to) AERN2.MP.Dyadic.Dyadic
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Real.Rational
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.Real.Type.CauchyReal AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.Real.Type.CauchyReal
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanSub (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanSub (AERN2.Real.Type.CauchyRealA to) GHC.Integer.Type.Integer
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanSub (AERN2.Real.Type.CauchyRealA to) GHC.Types.Int
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanSub (AERN2.Real.Type.CauchyRealA to) AERN2.MP.Dyadic.Dyadic
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanSub (AERN2.Real.Type.CauchyRealA to) GHC.Real.Rational
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.AddSub.CanSub AERN2.Real.Type.CauchyReal AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall AERN2.Real.Type.CauchyReal
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Integer.Type.Integer
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Types.Int
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Real.Type.CauchyRealA to) AERN2.MP.Dyadic.Dyadic
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Real.Rational
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.Real.Type.CauchyReal AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.Real.Type.CauchyReal


-- | Field operations on Cauchy Real numbers.
module AERN2.Real.Field
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Field.CanDiv (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Field.CanDiv (AERN2.Real.Type.CauchyRealA to) GHC.Integer.Type.Integer
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Field.CanDiv (AERN2.Real.Type.CauchyRealA to) GHC.Types.Int
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Field.CanDiv GHC.Types.Int (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Field.CanDiv (AERN2.Real.Type.CauchyRealA to) AERN2.MP.Dyadic.Dyadic
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Field.CanDiv (AERN2.Real.Type.CauchyRealA to) GHC.Real.Rational
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Field.CanDiv AERN2.Real.Type.CauchyReal AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall AERN2.Real.Type.CauchyReal
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanPow (AERN2.Real.Type.CauchyRealA to) GHC.Integer.Type.Integer
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanPow (AERN2.Real.Type.CauchyRealA to) GHC.Types.Int


-- | Elementary functions on Cauchy Real numbers.
module AERN2.Real.Elementary
expA :: (QAArrow to, CanExp t, ExpType t ~ CauchyReal) => t -> CauchyRealA to
logA :: (QAArrow to, CanLog t, LogType t ~ CauchyReal) => t -> CauchyRealA to
pi :: CauchyReal
piA :: (QAArrow to) => CauchyRealA to
sqrtA :: (QAArrow to, CanSqrt t, SqrtType t ~ CauchyReal) => t -> CauchyRealA to
sinA :: (QAArrow to, CanSinCos t, SinCosType t ~ CauchyReal) => t -> CauchyRealA to
cosA :: (QAArrow to, CanSinCos t, SinCosType t ~ CauchyReal) => t -> CauchyRealA to
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Elementary.CanExp (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Elementary.CanExp GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Elementary.CanExp GHC.Types.Int
instance Numeric.MixedTypes.Elementary.CanExp AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Elementary.CanExp GHC.Real.Rational
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Elementary.CanLog (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Elementary.CanLog GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Elementary.CanLog GHC.Types.Int
instance Numeric.MixedTypes.Elementary.CanLog AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Elementary.CanLog GHC.Real.Rational
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanPow (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanPow GHC.Integer.Type.Integer (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanPow GHC.Types.Int (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanPow (AERN2.Real.Type.CauchyRealA to) AERN2.MP.Dyadic.Dyadic
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanPow AERN2.MP.Dyadic.Dyadic (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanPow (AERN2.Real.Type.CauchyRealA to) GHC.Real.Rational
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Ring.CanPow GHC.Real.Rational (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Ring.CanPow AERN2.Real.Type.CauchyReal AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall AERN2.Real.Type.CauchyReal
instance Numeric.MixedTypes.Ring.CanPow GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanPow GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanPow GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanPow GHC.Real.Rational GHC.Real.Rational
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Elementary.CanSqrt (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Elementary.CanSqrt GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Elementary.CanSqrt GHC.Types.Int
instance Numeric.MixedTypes.Elementary.CanSqrt AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Elementary.CanSqrt GHC.Real.Rational
instance AERN2.QA.QAArrow to => Numeric.MixedTypes.Elementary.CanSinCos (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Elementary.CanSinCos GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Elementary.CanSinCos GHC.Types.Int
instance Numeric.MixedTypes.Elementary.CanSinCos AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Elementary.CanSinCos GHC.Real.Rational


-- | Tests for operations on cauchy real numbers.
--   
--   To run the tests using stack, execute:
--   
--   <pre>
--   stack test aern2-real --test-arguments "-a 1000 -m Real"
--   
--   </pre>
module AERN2.Real.Tests
specCauchyReal :: Spec

-- | A runtime representative of type <tt>CauchyReal</tt>. Used for
--   specialising polymorphic tests to concrete types.
tCauchyReal :: T CauchyReal
tCauchyRealAtAccuracy :: T CauchyRealAtAccuracy
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.Real.Comparison.CauchyRealAtAccuracy
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.Real.Type.CauchyReal


-- | Cauchy reals
module AERN2.Real

-- | An object we can ask queries about. Queries can be asked in some Arrow
--   <tt>to</tt>.
data QA to p
QA__ :: String -> Maybe (QAId to) -> [QAId to] -> p -> Q p -> (Q p) `to` (A p) -> QA to p
[qaName] :: QA to p -> String
[qaId] :: QA to p -> Maybe (QAId to)
[qaSources] :: QA to p -> [QAId to]
[qaProtocol] :: QA to p -> p
[qaSampleQ] :: QA to p -> Q p
[qaMakeQuery] :: QA to p -> (Q p) `to` (A p)
data CauchyRealP
pCR :: CauchyRealP
type CauchyRealA to = QA to CauchyRealP
type CauchyReal = CauchyRealA (->)
newCR :: (QAArrow to) => String -> [AnyProtocolQA to] -> Accuracy `to` MPBall -> CauchyRealA to
convergentList2CauchyRealA :: (QAArrow to) => String -> [MPBall] -> (CauchyRealA to)
seqByPrecision2CauchyRealA :: (QAArrow to) => String -> (Precision -> MPBall) -> (CauchyRealA to)
type CanBeReal t = CanBeRealA (->) t
real :: (CanBeRealA (->) t) => t -> CauchyReal
type CanBeRealA to t = ConvertibleExactly t (CauchyRealA to)
realA :: (CanBeRealA to t) => t -> CauchyRealA to
pi :: CauchyReal
piA :: (QAArrow to) => CauchyRealA to
expA :: (QAArrow to, CanExp t, ExpType t ~ CauchyReal) => t -> CauchyRealA to
logA :: (QAArrow to, CanLog t, LogType t ~ CauchyReal) => t -> CauchyRealA to
sqrtA :: (QAArrow to, CanSqrt t, SqrtType t ~ CauchyReal) => t -> CauchyRealA to
sinA :: (QAArrow to, CanSinCos t, SinCosType t ~ CauchyReal) => t -> CauchyRealA to
cosA :: (QAArrow to, CanSinCos t, SinCosType t ~ CauchyReal) => t -> CauchyRealA to
unaryOp :: (QAArrow to) => String -> (CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall) -> (CauchyRealA to -> (Accuracy `to` (Accuracy, Maybe MPBall))) -> CauchyRealA to -> CauchyRealA to
binaryOp :: (QAArrow to) => String -> (CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall) -> (CauchyRealA to -> CauchyRealA to -> (Accuracy `to` ((Accuracy, Maybe MPBall), (Accuracy, Maybe MPBall)))) -> CauchyRealA to -> CauchyRealA to -> CauchyRealA to
binaryOpWithPureArg :: (QAArrow to) => String -> (CatchingNumExceptions MPBall -> t -> CatchingNumExceptions MPBall) -> (CauchyRealA to -> t -> (Accuracy `to` (Accuracy, Maybe MPBall))) -> CauchyRealA to -> t -> CauchyRealA to
getCRFnNormLog :: (Arrow to) => CauchyRealA to -> (MPBall -> MPBall) -> Accuracy `to` (NormLog, MPBall)
getInitQ1FromSimple :: (Arrow to) => Accuracy `to` q -> r1 -> Accuracy `to` (q, Maybe MPBall)
getInitQ1TFromSimple :: (Arrow to) => Accuracy `to` q -> r1 -> t -> Accuracy `to` (q, Maybe MPBall)
getInitQ1Q2FromSimple :: (Arrow to) => Accuracy `to` (q, q) -> r1 -> r2 -> Accuracy `to` ((q, Maybe MPBall), (q, Maybe MPBall))
binaryWithBall :: (MPBall -> MPBall -> MPBall) -> CauchyReal -> MPBall -> MPBall


-- | Effort indicator to direct enclosure computation
module AERN2.Effort
type WithEffort t = QA (->) (WithEffortP t)
newtype WithEffortP t
WithEffortP :: t -> WithEffortP t
type Effort = Map String EffortItem
data EffortItem
EffortNum :: Integer -> EffortItem
[_effortNum] :: EffortItem -> Integer

-- | EffortFun { effortFun :: Integer -&gt; Integer } | EffortFun {
--   effortFunSampleArg :: Effort, effortFun :: Effort -&gt; Integer }
EffortSub :: Effort -> EffortItem
[_effortSub] :: EffortItem -> Effort
subs :: Traversal' Effort Effort
subE :: String -> Prism' Effort Effort
precE :: Traversal' Effort Integer
normaliseTopLevel :: Effort -> Effort
unifyPrecTopLevel :: Effort -> Effort
combineSampleEfforts :: Effort -> Effort -> (Effort, Effort -> Effort, Effort -> Effort)
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric t1 t2, GHC.Show.Show (Numeric.MixedTypes.AddSub.AddType t1 t2)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Effort.WithEffort t1) (AERN2.Effort.WithEffort t2)
instance GHC.Show.Show AERN2.Effort.EffortItem
instance GHC.Show.Show t => GHC.Show.Show (AERN2.Effort.WithEffortP t)
instance GHC.Show.Show t => AERN2.QA.QAProtocol (AERN2.Effort.WithEffortP t)
instance GHC.Show.Show t => AERN2.QA.QAProtocolCacheable (AERN2.Effort.WithEffortP t)

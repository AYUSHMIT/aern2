-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Exact real numbers via Cauchy sequences and MPFR
--   
--   Exact real numbers as Cauchy sequences of MPFR approximations.
--   
--   See module <a>AERN2.Real</a> for further documentation.
@package aern2-real
@version 0.1.0.0


-- | Cacheable question-answer protocols
module AERN2.QA.Protocol

-- | A QA protocol at this level is simply a pair of types.
class (Show p, Show (Q p), Show (A p)) => QAProtocol p where type Q p type A p where {
    type family Q p;
    type family A p;
}

-- | A QA protocol with a caching method.
class (QAProtocol p, HasOrderCertainly (Q p) (Q p)) => QAProtocolCacheable p where type QACache p where {
    type family QACache p;
}
newQACache :: QAProtocolCacheable p => p -> QACache p
lookupQACache :: QAProtocolCacheable p => p -> QACache p -> Q p -> (Maybe (A p), Maybe String)
updateQACache :: QAProtocolCacheable p => p -> Q p -> A p -> QACache p -> QACache p

-- | An object we can ask queries about. Queries can be asked in some Arrow
--   <tt>to</tt>.
data QA to p
QA__ :: String -> Maybe (QAId to) -> [QAId to] -> p -> Q p -> (Q p) `to` (QAPromiseA to (A p)) -> QA to p
[qaName] :: QA to p -> String
[qaId] :: QA to p -> Maybe (QAId to)
[qaSources] :: QA to p -> [QAId to]
[qaProtocol] :: QA to p -> p
[qaSampleQ] :: QA to p -> Q p
[qaMakeQueryGetPromise] :: QA to p -> (Q p) `to` (QAPromiseA to (A p))
type QAPromiseA to a = () `to` a

-- | An infix synonym of <a>qaMakeQuery</a>.
(?..) :: QA to p -> (Q p) `to` (QAPromiseA to (A p))
infix 1 ?..
data AnyProtocolQA to
AnyProtocolQA :: (QA to p) -> AnyProtocolQA to

-- | A class of Arrows suitable for use in QA objects.
class (ArrowChoice to, Eq (QAId to)) => QAArrow to where type QAId to newQA = defaultNewQA where {
    type family QAId to;
}

-- | Register a QA object, which leads to a change in its query processing
--   mechanism so that, eg, answers can be cached or computations assigned
--   to different threads/processes.
--   
--   The "sources" component of the incoming QA object can be used to
--   record the dependency graph among QA objects. After registration, the
--   QA object should have its list of dependencies **empty** as the
--   registration has recorded them elsewhere.
qaRegister :: (QAArrow to, QAProtocolCacheable p) => (QA to p) `to` (QA to p)

-- | Create a qa object. The object is not "registered" automatically.
--   Invoking this function does not lead to any <tt>to</tt>-arrow
--   computation. The function is an operation of <a>QAArrow</a> so that
--   for some arrows, the question-answer mechanism can be automatically
--   altered. In particular, this is used to make all objects in the
--   (-&gt;) arrow automatically (unsafely) caching their answers. For most
--   arrows, the default implementation is sufficient.
newQA :: (QAArrow to, QAProtocolCacheable p) => String -> [AnyProtocolQA to] -> p -> Q p -> (Q p) `to` (A p) -> QA to p
qaFulfilPromiseA :: QAArrow to => (QAPromiseA to a) `to` a
qaMakeQueryGetPromiseA :: QAArrow to => (QA to p, Q p) `to` (QAPromiseA to (A p))
defaultNewQA :: (QAArrow to, QAProtocolCacheable p) => String -> [AnyProtocolQA to] -> p -> Q p -> (Q p) `to` (A p) -> QA to p
qaMakeQuery :: (QAArrow to) => (QA to p) -> (Q p) `to` (A p)
qaMakeQueryA :: (QAArrow to) => (QA to p, Q p) `to` (A p)
qaMakeQueriesA :: (QAArrow to) => [(QA to p, Q p)] `to` [A p]
qaMakeQueryOnManyA :: (QAArrow to) => ([QA to p], Q p) `to` [A p]

-- | An infix synonym of <a>qaMakeQuery</a>.
(?) :: (QAArrow to) => QA to p -> (Q p) `to` (A p)
infix 1 ?

-- | An infix synonym of <a>qaRegister</a>.
(-:-) :: (QAArrow to, QAProtocolCacheable p) => (QA to p) `to` (QA to p)
infix 0 -:-

-- | An infix synonym of <a>qaMakeQueryA</a>.
(-?-) :: (QAArrow to) => (QA to p, Q p) `to` (A p)
infix 0 -?-

-- | An infix synonym of <a>qaMakeQueryGetPromiseA</a>.
(-?..-) :: (QAArrow to) => (QA to p, Q p) `to` (QAPromiseA to (A p))
infix 0 -?..-

-- | An infix synonym of <a>qaMakeQueriesA</a>.
(-???-) :: (QAArrow to) => [(QA to p, Q p)] `to` [A p]
infix 0 -???-

-- | An infix synonym of <a>qaMakeQueryOnManyA</a>.
(-<?>-) :: (QAArrow to) => ([QA to p], Q p) `to` [A p]
infix 0 -<?>-

-- | Run two queries in an interleaving manner, enabling parallelism.
qaMake2Queries :: (QAArrow to) => (QA to p1, QA to p2) -> (Q p1, Q p2) `to` (A p1, A p2)

-- | An infix synonym of <a>qaMake2Queries</a>.
(??) :: (QAArrow to) => (QA to p1, QA to p2) -> (Q p1, Q p2) `to` (A p1, A p2)
infix 1 ??

-- | Apply an arrow morphism on all elements of a list
mapA :: (ArrowChoice to) => (t1 `to` t2) -> ([t1] `to` [t2])
class CanSwitchArrow to1 to2
switchArrow :: CanSwitchArrow to1 to2 => (a `to1` b) -> (a `to2` b)
instance Control.Arrow.Arrow to => AERN2.QA.Protocol.CanSwitchArrow (->) to
instance (AERN2.QA.Protocol.CanSwitchArrow to1 to2, AERN2.QA.Protocol.QAArrow to1, AERN2.QA.Protocol.QAArrow to2, AERN2.QA.Protocol.QAProtocolCacheable p) => Numeric.MixedTypes.Literals.ConvertibleExactly (AERN2.QA.Protocol.QA to1 p) (AERN2.QA.Protocol.QA to2 p)


-- | QA net plain evaluation with unsafe IO caching
module AERN2.QA.Strategy.CachedUnsafe

-- | A global variable controlling whether unsafe caching is used in QA
--   objects in the (-&gt;) arrow
qaUnsafeCachingMV :: MVar Bool
instance AERN2.QA.Protocol.QAArrow (->)


-- | QA net parallel evaluation
module AERN2.QA.Strategy.Parallel
type QAParA = Kleisli QAParM
executeQAParA :: (QAParA () a) -> IO a
instance GHC.Base.Functor AERN2.QA.Strategy.Parallel.QAParM
instance GHC.Base.Applicative AERN2.QA.Strategy.Parallel.QAParM
instance GHC.Base.Monad AERN2.QA.Strategy.Parallel.QAParM
instance Control.Monad.IO.Class.MonadIO AERN2.QA.Strategy.Parallel.QAParM
instance AERN2.QA.Protocol.QAArrow AERN2.QA.Strategy.Parallel.QAParA


-- | QA network log data structure
module AERN2.QA.NetLog
type QANetLog = [QANetLogItem]
data QANetLogItem
QANetLogCreate :: ValueId -> [ValueId] -> String -> QANetLogItem
QANetLogQuery :: ValueId -> String -> QANetLogItem
QANetLogAnswer :: ValueId -> String -> String -> QANetLogItem
newtype ValueId
ValueId :: Integer -> ValueId
printQANetLogThenResult :: (Show a) => (QANetLog, a) -> IO ()
printQALog :: QANetLog -> IO ()
formatQALog :: Integer -> QANetLog -> String
instance GHC.Enum.Enum AERN2.QA.NetLog.ValueId
instance GHC.Classes.Ord AERN2.QA.NetLog.ValueId
instance GHC.Classes.Eq AERN2.QA.NetLog.ValueId
instance GHC.Show.Show AERN2.QA.NetLog.ValueId
instance GHC.Show.Show AERN2.QA.NetLog.QANetLogItem


-- | A monad-generic state of a QA net.
module AERN2.QA.Strategy.Cached.NetState
data QANetState m
QANetState :: Map ValueId (AnyQAComputation m) -> QANetLog -> Bool -> QANetState m
[net_id2value] :: QANetState m -> Map ValueId (AnyQAComputation m)
[net_log] :: QANetState m -> QANetLog
[net_should_cache] :: QANetState m -> Bool
initQANetState :: Bool -> QANetState m
data AnyQAComputation m
AnyQAComputation :: (QAComputation m p) -> AnyQAComputation m
data QAComputation m p

-- | used only if a suitable answer is not in the above cache
QAComputation :: p -> (QACache p) -> (Q p -> m (QAPromiseA (Kleisli m) (A p))) -> QAComputation m p
insertNode :: (QAProtocolCacheable p) => p -> String -> [ValueId] -> (Q p -> m (QAPromiseA (Kleisli m) (A p))) -> QANetState m -> (ValueId, QANetState m)
logQuery :: QANetState m -> ValueId -> String -> QANetState m
logAnswerUpdateCache :: (QAProtocolCacheable p) => QANetState m -> p -> ValueId -> (String, String, QACache p) -> QANetState m
getAnswerPromise :: (QAProtocolCacheable p, Monad m) => QANetState m -> p -> ValueId -> Q p -> m (() -> m (A p, [Char], QACache p))


-- | QA net evaluation with answer caching
module AERN2.QA.Strategy.Cached.Arrow
type QACachedA = Kleisli QACachedM
executeQACachedA :: (QACachedA () a) -> (QANetLog, a)
executeQAUncachedA :: (QACachedA () a) -> (QANetLog, a)
instance GHC.Base.Functor AERN2.QA.Strategy.Cached.Arrow.QACachedM
instance GHC.Base.Applicative AERN2.QA.Strategy.Cached.Arrow.QACachedM
instance GHC.Base.Monad AERN2.QA.Strategy.Cached.Arrow.QACachedM
instance AERN2.QA.Protocol.QAArrow AERN2.QA.Strategy.Cached.Arrow.QACachedA


-- | QA net evaluation with answer caching
module AERN2.QA.Strategy.Cached


-- | The type of Cauchy real numbers
module AERN2.AccuracySG

-- | An accuracy specification which includes a soft target "guide"
--   accuracy in addition to the usual string accuracy requirement.
data AccuracySG
AccuracySG :: Accuracy -> Accuracy -> AccuracySG
[_acStrict] :: AccuracySG -> Accuracy
[_acGuide] :: AccuracySG -> Accuracy
acSG0 :: AccuracySG
accuracySG :: Accuracy -> AccuracySG
bitsS :: Integer -> AccuracySG
bitsSG :: Integer -> Integer -> AccuracySG
accuracySGdefaultTolerance :: Integer
instance GHC.Classes.Eq AERN2.AccuracySG.AccuracySG
instance GHC.Show.Show AERN2.AccuracySG.AccuracySG
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.AccuracySG.AccuracySG AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.AccuracySG.AccuracySG AERN2.AccuracySG.AccuracySG
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.AccuracySG.AccuracySG AERN2.AccuracySG.AccuracySG
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Accuracy.Accuracy AERN2.AccuracySG.AccuracySG
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.AccuracySG.AccuracySG AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.AccuracySG.AccuracySG AERN2.AccuracySG.AccuracySG
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.AccuracySG.AccuracySG GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer AERN2.AccuracySG.AccuracySG
instance Numeric.MixedTypes.AddSub.CanSub AERN2.AccuracySG.AccuracySG GHC.Integer.Type.Integer


-- | The type of Cauchy real numbers
module AERN2.Real.Type
data CauchyRealP
pCR :: CauchyRealP
realName :: CauchyRealA to -> String
realId :: CauchyRealA to -> Maybe (QAId to)
realSources :: CauchyRealA to -> [QAId to]
realRename :: (String -> String) -> CauchyRealA to -> CauchyRealA to

-- | Get a ball approximation of the real number with at least the
--   specified accuracy. (A specialisation of <a>qaMakeQuery</a> for Cauchy
--   reals.)
realWithAccuracy :: (QAArrow to) => CauchyRealA to -> AccuracySG `to` MPBall
realWithAccuracyA :: (QAArrow to) => (CauchyRealA to, AccuracySG) `to` MPBall
realsWithAccuracyA :: (QAArrow to) => ([CauchyRealA to], AccuracySG) `to` [MPBall]
type CauchyRealA to = QA to CauchyRealP
type CauchyReal = CauchyRealA (->)
newCR :: (QAArrow to) => String -> [AnyProtocolQA to] -> AccuracySG `to` MPBall -> CauchyRealA to
convergentList2CauchyRealA :: (QAArrow to) => String -> [MPBall] -> (CauchyRealA to)
seqByPrecision2CauchyRealA :: (QAArrow to) => String -> (Precision -> MPBall) -> (CauchyRealA to)
type CanBeReal t = CanBeRealA (->) t
real :: (CanBeRealA (->) t) => t -> CauchyReal
type CanBeRealA to t = ConvertibleExactly t (CauchyRealA to)
realA :: (CanBeRealA to t) => t -> CauchyRealA to
type CanBeComplex t = CanBeComplexA (->) t
complex :: (CanBeComplexA (->) t) => t -> Complex CauchyReal
type CanBeComplexA to t = ConvertibleExactly t (Complex (CauchyRealA to))
complexA :: (CanBeComplexA to t) => t -> Complex (CauchyRealA to)

-- | Given a list <tt>[(a1,b1),(a2,b2),...]</tt> and assuming that at least
--   one of <tt>a1,a2,...</tt> is non-zero, pick one of them and return the
--   corresponding pair <tt>(ai,bi)</tt>.
--   
--   If none of <tt>a1,a2,...</tt> is zero, either throw an exception or
--   loop forever.
pickNonZeroRealA :: (QAArrow to) => [(CauchyRealA to, s)] `to` (CauchyRealA to, s)
instance GHC.Show.Show AERN2.Real.Type.CauchyRealP
instance AERN2.QA.Protocol.QAProtocol AERN2.Real.Type.CauchyRealP
instance AERN2.QA.Protocol.QAProtocolCacheable AERN2.Real.Type.CauchyRealP
instance GHC.Show.Show AERN2.Real.Type.CauchyReal
instance Numeric.CatchingExceptions.Type.CanTestValid AERN2.Real.Type.CauchyReal
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Dyadic.Dyadic (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Real.Rational (AERN2.Real.Type.CauchyRealA to)
instance AERN2.MP.Precision.ConvertibleWithPrecision AERN2.Real.Type.CauchyReal AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.CanPickNonZero AERN2.Real.Type.CauchyReal


-- | Auxiliary functions for CR operations
module AERN2.Real.Helpers
getCRFnNormLog :: (QAArrow to) => CauchyRealA to -> (MPBall -> MPBall) -> AccuracySG `to` (NormLog, MPBall)
binaryWithBall :: (MPBall -> MPBall -> MPBall) -> CauchyReal -> MPBall -> MPBall
binaryWithDouble :: (Double -> Double -> Double) -> CauchyReal -> Double -> Double
unaryOp :: (QAArrow to) => String -> (CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall) -> (CauchyRealA to -> (AccuracySG `to` (AccuracySG, Maybe MPBall))) -> CauchyRealA to -> CauchyRealA to
binaryOp :: (QAArrow to) => String -> (CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall) -> (CauchyRealA to -> CauchyRealA to -> (AccuracySG `to` ((AccuracySG, Maybe MPBall), (AccuracySG, Maybe MPBall)))) -> CauchyRealA to -> CauchyRealA to -> CauchyRealA to
binaryOpWithPureArg :: (QAArrow to) => String -> (CatchingNumExceptions MPBall -> t -> CatchingNumExceptions MPBall) -> (CauchyRealA to -> t -> (AccuracySG `to` (AccuracySG, Maybe MPBall))) -> CauchyRealA to -> t -> CauchyRealA to
getInitQ1FromSimple :: (Arrow to) => AccuracySG `to` q -> r1 -> AccuracySG `to` (q, Maybe MPBall)
getInitQ1TFromSimple :: (Arrow to) => AccuracySG `to` q -> r1 -> t -> AccuracySG `to` (q, Maybe MPBall)
getInitQ1Q2FromSimple :: (Arrow to) => AccuracySG `to` (q, q) -> r1 -> r2 -> AccuracySG `to` ((q, Maybe MPBall), (q, Maybe MPBall))
instance Data.Convertible.Base.Convertible AERN2.Real.Type.CauchyReal GHC.Types.Double


-- | Comparison operations on Cauchy Real numbers.
module AERN2.Real.Comparison
data CauchyBoolP
CauchyBoolP :: CauchyBoolP
type CauchyBoolA to = QA to CauchyBoolP
type CauchyBool = CauchyBoolA (->)

-- | CauchyRealAtAccuracy exists only so that we can QuickCheck that
--   CauchyReal satisfies properties whose statement relies on an instance
--   of HasEqCertainly. CauchyReal is not an instance but
--   CauchyRealAtAccuracy is.
data CauchyRealAtAccuracy
CauchyRealAtAccuracy :: CauchyReal -> AccuracySG -> CauchyRealAtAccuracy
instance GHC.Show.Show AERN2.Real.Comparison.CauchyRealAtAccuracy
instance GHC.Show.Show AERN2.Real.Comparison.CauchyBoolP
instance AERN2.QA.Protocol.QAProtocol AERN2.Real.Comparison.CauchyBoolP
instance AERN2.QA.Protocol.QAProtocolCacheable AERN2.Real.Comparison.CauchyBoolP
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Bool (AERN2.Real.Comparison.CauchyBoolA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Bool.CanNeg (AERN2.Real.Comparison.CauchyBoolA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Bool.CanAndOrAsymmetric (AERN2.Real.Comparison.CauchyBoolA to) (AERN2.Real.Comparison.CauchyBoolA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Eq.HasEqAsymmetric (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ord.HasOrderAsymmetric (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.Real.Comparison.CauchyRealAtAccuracy AERN2.Real.Comparison.CauchyRealAtAccuracy
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.Real.Comparison.CauchyRealAtAccuracy AERN2.Real.Comparison.CauchyRealAtAccuracy
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanAbs (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Integer.Type.Integer
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Types.Int
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (AERN2.Real.Type.CauchyRealA to) AERN2.MP.Dyadic.Dyadic
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Real.Rational
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Real.Rational (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.Real.Type.CauchyReal AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.Real.Type.CauchyReal


-- | Ring operations on Cauchy Real numbers.
module AERN2.Real.Ring
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Bool.CanNeg (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Integer.Type.Integer
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Types.Int
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Real.Type.CauchyRealA to) AERN2.MP.Dyadic.Dyadic
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Real.Rational
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.Real.Type.CauchyReal AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.Real.Type.CauchyReal
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.Real.Type.CauchyReal GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Double AERN2.Real.Type.CauchyReal
instance (AERN2.QA.Protocol.QAArrow to, Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Real.Type.CauchyRealA to) t) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Real.Type.CauchyRealA to) (Data.Complex.Complex t)
instance (AERN2.QA.Protocol.QAArrow to, Numeric.MixedTypes.AddSub.CanAddAsymmetric t (AERN2.Real.Type.CauchyRealA to)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (Data.Complex.Complex t) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanSub (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanSub (AERN2.Real.Type.CauchyRealA to) GHC.Integer.Type.Integer
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanSub (AERN2.Real.Type.CauchyRealA to) GHC.Types.Int
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanSub (AERN2.Real.Type.CauchyRealA to) AERN2.MP.Dyadic.Dyadic
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanSub (AERN2.Real.Type.CauchyRealA to) GHC.Real.Rational
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.AddSub.CanSub AERN2.Real.Type.CauchyReal AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall AERN2.Real.Type.CauchyReal
instance Numeric.MixedTypes.AddSub.CanSub AERN2.Real.Type.CauchyReal GHC.Types.Double
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Double AERN2.Real.Type.CauchyReal
instance (AERN2.QA.Protocol.QAArrow to, Numeric.MixedTypes.AddSub.CanAdd (AERN2.Real.Type.CauchyRealA to) t, Numeric.MixedTypes.Bool.CanNegSameType t) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Real.Type.CauchyRealA to) (Data.Complex.Complex t)
instance (AERN2.QA.Protocol.QAArrow to, Numeric.MixedTypes.AddSub.CanAdd t (AERN2.Real.Type.CauchyRealA to)) => Numeric.MixedTypes.AddSub.CanSub (Data.Complex.Complex t) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Integer.Type.Integer
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Types.Int
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Real.Type.CauchyRealA to) AERN2.MP.Dyadic.Dyadic
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Real.Type.CauchyRealA to) GHC.Real.Rational
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.Real.Type.CauchyReal AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.Real.Type.CauchyReal
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.Real.Type.CauchyReal GHC.Types.Double
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Double AERN2.Real.Type.CauchyReal
instance Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Real.Type.CauchyRealA to) t => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Real.Type.CauchyRealA to) (Data.Complex.Complex t)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric t (AERN2.Real.Type.CauchyRealA to) => Numeric.MixedTypes.Ring.CanMulAsymmetric (Data.Complex.Complex t) (AERN2.Real.Type.CauchyRealA to)


-- | Field operations on Cauchy Real numbers.
module AERN2.Real.Field
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Field.CanDiv (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Field.CanDiv (AERN2.Real.Type.CauchyRealA to) GHC.Integer.Type.Integer
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Field.CanDiv (AERN2.Real.Type.CauchyRealA to) GHC.Types.Int
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Field.CanDiv GHC.Types.Int (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Field.CanDiv (AERN2.Real.Type.CauchyRealA to) AERN2.MP.Dyadic.Dyadic
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Field.CanDiv (AERN2.Real.Type.CauchyRealA to) GHC.Real.Rational
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Field.CanDiv AERN2.Real.Type.CauchyReal AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall AERN2.Real.Type.CauchyReal
instance Numeric.MixedTypes.Field.CanDiv AERN2.Real.Type.CauchyReal GHC.Types.Double
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Double AERN2.Real.Type.CauchyReal
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanPow (AERN2.Real.Type.CauchyRealA to) GHC.Integer.Type.Integer
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanPow (AERN2.Real.Type.CauchyRealA to) GHC.Types.Int


-- | Elementary functions on Cauchy Real numbers.
module AERN2.Real.Elementary
expA :: (QAArrow to, CanExp t, ExpType t ~ CauchyReal) => t -> CauchyRealA to
logA :: (QAArrow to, CanLog t, LogType t ~ CauchyReal) => t -> CauchyRealA to

-- | To get <tt>pi</tt> in an arbitrary arrow, use <a>piA</a>.
pi :: CauchyReal
piA :: (QAArrow to) => CauchyRealA to
sqrtA :: (QAArrow to, CanSqrt t, SqrtType t ~ CauchyReal) => t -> CauchyRealA to
sinA :: (QAArrow to, CanSinCos t, SinCosType t ~ CauchyReal) => t -> CauchyRealA to
cosA :: (QAArrow to, CanSinCos t, SinCosType t ~ CauchyReal) => t -> CauchyRealA to
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Elementary.CanExp (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Elementary.CanExp GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Elementary.CanExp GHC.Types.Int
instance Numeric.MixedTypes.Elementary.CanExp AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Elementary.CanExp GHC.Real.Rational
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Elementary.CanLog (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Elementary.CanLog GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Elementary.CanLog GHC.Types.Int
instance Numeric.MixedTypes.Elementary.CanLog AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Elementary.CanLog GHC.Real.Rational
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanPow (AERN2.Real.Type.CauchyRealA to) (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanPow GHC.Integer.Type.Integer (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanPow GHC.Types.Int (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanPow (AERN2.Real.Type.CauchyRealA to) AERN2.MP.Dyadic.Dyadic
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanPow AERN2.MP.Dyadic.Dyadic (AERN2.Real.Type.CauchyRealA to)
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanPow (AERN2.Real.Type.CauchyRealA to) GHC.Real.Rational
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Ring.CanPow GHC.Real.Rational (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Ring.CanPow AERN2.Real.Type.CauchyReal AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall AERN2.Real.Type.CauchyReal
instance Numeric.MixedTypes.Ring.CanPow GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanPow GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanPow GHC.Integer.Type.Integer GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanPow GHC.Types.Int GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanPow GHC.Real.Rational GHC.Real.Rational
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Elementary.CanSqrt (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Elementary.CanSqrt GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Elementary.CanSqrt GHC.Types.Int
instance Numeric.MixedTypes.Elementary.CanSqrt AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Elementary.CanSqrt GHC.Real.Rational
instance AERN2.QA.Protocol.QAArrow to => Numeric.MixedTypes.Elementary.CanSinCos (AERN2.Real.Type.CauchyRealA to)
instance Numeric.MixedTypes.Elementary.CanSinCos GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Elementary.CanSinCos GHC.Types.Int
instance Numeric.MixedTypes.Elementary.CanSinCos AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Elementary.CanSinCos GHC.Real.Rational


-- | Tests for operations on cauchy real numbers.
--   
--   To run the tests using stack, execute:
--   
--   <pre>
--   stack test aern2-real --test-arguments "-a 1000 -m Real"
--   
--   </pre>
module AERN2.Real.Tests
specCauchyReal :: Spec

-- | A runtime representative of type <tt>CauchyReal</tt>. Used for
--   specialising polymorphic tests to concrete types.
tCauchyReal :: T CauchyReal
tCauchyRealAtAccuracy :: T CauchyRealAtAccuracy
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.Real.Comparison.CauchyRealAtAccuracy
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.Real.Type.CauchyReal


-- | Cauchy reals
module AERN2.Real
data CauchyRealP
pCR :: CauchyRealP
realName :: CauchyRealA to -> String
realId :: CauchyRealA to -> Maybe (QAId to)
realSources :: CauchyRealA to -> [QAId to]
realRename :: (String -> String) -> CauchyRealA to -> CauchyRealA to

-- | Get a ball approximation of the real number with at least the
--   specified accuracy. (A specialisation of <a>qaMakeQuery</a> for Cauchy
--   reals.)
realWithAccuracy :: (QAArrow to) => CauchyRealA to -> AccuracySG `to` MPBall

-- | An infix synonym of <a>qaMakeQuery</a>.
(?) :: (QAArrow to) => QA to p -> (Q p) `to` (A p)
infix 1 ?
realWithAccuracyA :: (QAArrow to) => (CauchyRealA to, AccuracySG) `to` MPBall
realsWithAccuracyA :: (QAArrow to) => ([CauchyRealA to], AccuracySG) `to` [MPBall]
type CauchyRealA to = QA to CauchyRealP
type CauchyReal = CauchyRealA (->)
newCR :: (QAArrow to) => String -> [AnyProtocolQA to] -> AccuracySG `to` MPBall -> CauchyRealA to

-- | An infix synonym of <a>qaRegister</a>.
(-:-) :: (QAArrow to, QAProtocolCacheable p) => (QA to p) `to` (QA to p)
infix 0 -:-
convergentList2CauchyRealA :: (QAArrow to) => String -> [MPBall] -> (CauchyRealA to)
seqByPrecision2CauchyRealA :: (QAArrow to) => String -> (Precision -> MPBall) -> (CauchyRealA to)
type CanBeReal t = CanBeRealA (->) t
real :: (CanBeRealA (->) t) => t -> CauchyReal
type CanBeRealA to t = ConvertibleExactly t (CauchyRealA to)
realA :: (CanBeRealA to t) => t -> CauchyRealA to
type CanBeComplex t = CanBeComplexA (->) t
complex :: (CanBeComplexA (->) t) => t -> Complex CauchyReal
type CanBeComplexA to t = ConvertibleExactly t (Complex (CauchyRealA to))
complexA :: (CanBeComplexA to t) => t -> Complex (CauchyRealA to)

-- | To get <tt>pi</tt> in an arbitrary arrow, use <a>piA</a>.
pi :: CauchyReal
piA :: (QAArrow to) => CauchyRealA to
expA :: (QAArrow to, CanExp t, ExpType t ~ CauchyReal) => t -> CauchyRealA to
logA :: (QAArrow to, CanLog t, LogType t ~ CauchyReal) => t -> CauchyRealA to
sqrtA :: (QAArrow to, CanSqrt t, SqrtType t ~ CauchyReal) => t -> CauchyRealA to
sinA :: (QAArrow to, CanSinCos t, SinCosType t ~ CauchyReal) => t -> CauchyRealA to
cosA :: (QAArrow to, CanSinCos t, SinCosType t ~ CauchyReal) => t -> CauchyRealA to
unaryOp :: (QAArrow to) => String -> (CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall) -> (CauchyRealA to -> (AccuracySG `to` (AccuracySG, Maybe MPBall))) -> CauchyRealA to -> CauchyRealA to
binaryOp :: (QAArrow to) => String -> (CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall) -> (CauchyRealA to -> CauchyRealA to -> (AccuracySG `to` ((AccuracySG, Maybe MPBall), (AccuracySG, Maybe MPBall)))) -> CauchyRealA to -> CauchyRealA to -> CauchyRealA to
binaryOpWithPureArg :: (QAArrow to) => String -> (CatchingNumExceptions MPBall -> t -> CatchingNumExceptions MPBall) -> (CauchyRealA to -> t -> (AccuracySG `to` (AccuracySG, Maybe MPBall))) -> CauchyRealA to -> t -> CauchyRealA to
getCRFnNormLog :: (QAArrow to) => CauchyRealA to -> (MPBall -> MPBall) -> AccuracySG `to` (NormLog, MPBall)
getInitQ1FromSimple :: (Arrow to) => AccuracySG `to` q -> r1 -> AccuracySG `to` (q, Maybe MPBall)
getInitQ1TFromSimple :: (Arrow to) => AccuracySG `to` q -> r1 -> t -> AccuracySG `to` (q, Maybe MPBall)
getInitQ1Q2FromSimple :: (Arrow to) => AccuracySG `to` (q, q) -> r1 -> r2 -> AccuracySG `to` ((q, Maybe MPBall), (q, Maybe MPBall))
binaryWithBall :: (MPBall -> MPBall -> MPBall) -> CauchyReal -> MPBall -> MPBall
_addslACachedPrint :: IO ()
_addslAParPrint :: IO ()

-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Exact real functions
--   
--   TODO
@package aern2-fun
@version 0.1.0.0


-- | Basics of unary sparse polynomials
module AERN2.Poly.Basics

-- | A shortcut type constraint for types suitable as coefficients of our
--   polynomials, loose enough to permit Integer coefficients.
type PolyCoeffRing c = (Ring c, HasIntegers c, HasAccuracy c, HasNorm c, Show c)

-- | A shortcut type constraint for types suitable as coefficients of our
--   polynomials, loose enough to permit Rational coefficients.
type PolyCoeffField c = (PolyCoeffRing c, Field c, HasDyadics c, CanAddSubMulDivBy c Dyadic)

-- | a shortcut type constraint for types suitable as coefficients of our
--   polynomials
type PolyCoeffBall c = (PolyCoeffField c, CanAddSubMulDivBy c CauchyReal, IsInterval c c, IsBall c, CanSetPrecision c)
data Poly c
Poly :: Terms c -> Poly c
[poly_terms] :: Poly c -> Terms c
type Degree = Integer
type Terms c = Map Degree c
terms_empty :: Terms c
terms_size :: Terms c -> Integer
terms_insertWith :: (c -> c -> c) -> Degree -> c -> Terms c -> Terms c
terms_toList :: Terms c -> [(Degree, c)]
terms_toDescList :: Terms c -> [(Degree, c)]
terms_fromList :: (HasIntegers c) => [(Degree, c)] -> Terms c
terms_fromListAddCoeffs :: (CanAddSameType c, HasIntegers c) => [(Degree, c)] -> Terms c
terms_unionWith :: (c -> c -> c) -> Terms c -> Terms c -> Terms c
terms_map :: (c1 -> c2) -> Terms c1 -> Terms c2
terms_filterKeepConst :: (Degree -> c -> Bool) -> Terms c -> Terms c
terms_filterMayLoseConst :: (Degree -> c -> Bool) -> Terms c -> Terms c
terms_degree :: Terms c -> Degree
terms_degrees :: Terms c -> [Degree]
terms_coeffs :: Terms c -> [c]
terms_updateConst :: (HasIntegers c) => (c -> c) -> Terms c -> Terms c
terms_lookupCoeff :: (HasIntegers c) => (Terms c) -> Degree -> c
terms_lookupCoeffDoubleConstTerm :: (HasIntegers c, CanAddSameType c) => (Terms c) -> Degree -> c
formatTerms :: (HasIntegers c) => (c -> (String, Bool, Bool)) -> Terms c -> String
instance Numeric.MixedTypes.Field.CanDivBy c0 GHC.Integer.Type.Integer => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Basics.Poly c0) GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Field.CanDivBy c0 GHC.Types.Int => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Basics.Poly c0) GHC.Types.Int
instance Numeric.MixedTypes.Field.CanDivBy c0 GHC.Real.Rational => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Basics.Poly c0) GHC.Real.Rational
instance Numeric.MixedTypes.Field.CanDivBy c0 AERN2.MP.Dyadic.Dyadic => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Basics.Poly c0) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Field.CanDivBy c0 AERN2.MP.Ball.Type.MPBall => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Basics.Poly c0) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.CanDivBy c0 AERN2.Real.Type.CauchyReal => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Basics.Poly c0) AERN2.Real.Type.CauchyReal
instance (GHC.Show.Show c, Numeric.MixedTypes.Literals.HasIntegers c) => GHC.Show.Show (AERN2.Poly.Basics.Poly c)
instance Numeric.MixedTypes.Ring.CanMulBy c0 GHC.Integer.Type.Integer => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer (AERN2.Poly.Basics.Poly c0)
instance Numeric.MixedTypes.Ring.CanMulBy c0 GHC.Integer.Type.Integer => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Basics.Poly c0) GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulBy c0 GHC.Types.Int => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int (AERN2.Poly.Basics.Poly c0)
instance Numeric.MixedTypes.Ring.CanMulBy c0 GHC.Types.Int => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Basics.Poly c0) GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulBy c0 GHC.Real.Rational => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational (AERN2.Poly.Basics.Poly c0)
instance Numeric.MixedTypes.Ring.CanMulBy c0 GHC.Real.Rational => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Basics.Poly c0) GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulBy c0 AERN2.MP.Dyadic.Dyadic => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Poly.Basics.Poly c0)
instance Numeric.MixedTypes.Ring.CanMulBy c0 AERN2.MP.Dyadic.Dyadic => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Basics.Poly c0) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulBy c0 AERN2.MP.Ball.Type.MPBall => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall (AERN2.Poly.Basics.Poly c0)
instance Numeric.MixedTypes.Ring.CanMulBy c0 AERN2.MP.Ball.Type.MPBall => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Basics.Poly c0) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulBy c0 AERN2.Real.Type.CauchyReal => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.Real.Type.CauchyReal (AERN2.Poly.Basics.Poly c0)
instance Numeric.MixedTypes.Ring.CanMulBy c0 AERN2.Real.Type.CauchyReal => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Basics.Poly c0) AERN2.Real.Type.CauchyReal
instance (Numeric.MixedTypes.Bool.CanNegSameType c0, Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer (AERN2.Poly.Basics.Poly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Basics.Poly c0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.Bool.CanNegSameType c0, Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Types.Int, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int (AERN2.Poly.Basics.Poly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Types.Int, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Basics.Poly c0) GHC.Types.Int
instance (Numeric.MixedTypes.Bool.CanNegSameType c0, Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Real.Rational, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational (AERN2.Poly.Basics.Poly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Real.Rational, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Basics.Poly c0) GHC.Real.Rational
instance (Numeric.MixedTypes.Bool.CanNegSameType c0, Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic (AERN2.Poly.Basics.Poly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Basics.Poly c0) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.Bool.CanNegSameType c0, Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall (AERN2.Poly.Basics.Poly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Basics.Poly c0) AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.Bool.CanNegSameType c0, Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub AERN2.Real.Type.CauchyReal (AERN2.Poly.Basics.Poly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Basics.Poly c0) AERN2.Real.Type.CauchyReal
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer (AERN2.Poly.Basics.Poly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Basics.Poly c0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Types.Int, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int (AERN2.Poly.Basics.Poly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Types.Int, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Basics.Poly c0) GHC.Types.Int
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Real.Rational, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational (AERN2.Poly.Basics.Poly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Real.Rational, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Basics.Poly c0) GHC.Real.Rational
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Poly.Basics.Poly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Basics.Poly c0) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall (AERN2.Poly.Basics.Poly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Basics.Poly c0) AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.Real.Type.CauchyReal (AERN2.Poly.Basics.Poly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Basics.Poly c0) AERN2.Real.Type.CauchyReal
instance (Numeric.MixedTypes.Bool.CanNegSameType c, Numeric.MixedTypes.AddSub.CanAddSameType c) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Basics.Poly c) (AERN2.Poly.Basics.Poly c)
instance AERN2.MP.Precision.HasPrecision c => AERN2.MP.Precision.HasPrecision (AERN2.Poly.Basics.Poly c)
instance AERN2.MP.Precision.CanSetPrecision c => AERN2.MP.Precision.CanSetPrecision (AERN2.Poly.Basics.Poly c)
instance AERN2.MP.Accuracy.HasAccuracy c => AERN2.MP.Accuracy.HasAccuracy (AERN2.Poly.Basics.Poly c)
instance Numeric.MixedTypes.Bool.CanNegSameType c => Numeric.MixedTypes.Bool.CanNeg (AERN2.Poly.Basics.Poly c)
instance Numeric.MixedTypes.AddSub.CanAddSameType c => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Basics.Poly c) (AERN2.Poly.Basics.Poly c)

module AERN2.Poly.Power.Type
iterateUntilAccurate :: (Precision -> a -> b) -> (b -> Bool) -> Precision -> a -> b
iterateUntilDefined :: (Precision -> a -> Maybe b) -> Precision -> a -> b
_powPoly_geomPoly :: Integer -> PowPoly MPBall
_powPoly_truncatedSin :: Integer -> PowPoly MPBall
_powPoly_truncatedSin_rat :: Integer -> PowPoly Rational
data PowPoly c
PowPoly :: Poly c -> PowPoly c
[powPoly_poly] :: PowPoly c -> Poly c
powPoly_centre :: PowPoly MPBall -> PowPoly MPBall
powPoly_radius :: PowPoly MPBall -> ErrorBound
derivative :: (HasIntegers c, CanMulAsymmetric Integer c, MulType Integer c ~ c) => PowPoly c -> PowPoly c
derivative_exact :: PowPoly MPBall -> PowPoly MPBall
fromIntegerList :: (HasIntegers c) => [(Integer, Integer)] -> PowPoly c
fromList :: (HasIntegers c) => [(Integer, c)] -> PowPoly c
degree :: PowPoly c -> Integer
shiftRight :: Integer -> PowPoly c -> PowPoly c
shiftLeft :: Integer -> PowPoly c -> PowPoly c
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer (AERN2.Poly.Power.Type.PowPoly GHC.Integer.Type.Integer)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational (AERN2.Poly.Power.Type.PowPoly GHC.Real.Rational)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Poly.Power.Type.PowPoly AERN2.MP.Dyadic.Dyadic)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall (AERN2.Poly.Power.Type.PowPoly AERN2.MP.Ball.Type.MPBall)
instance (Numeric.MixedTypes.Ring.CanMulSameType c, Numeric.MixedTypes.AddSub.CanAddSameType c, Numeric.MixedTypes.Literals.HasIntegers c, Numeric.MixedTypes.Ring.CanMulAsymmetric c (AERN2.Poly.Basics.Poly c), Numeric.MixedTypes.Ring.MulType c (AERN2.Poly.Basics.Poly c) ~ AERN2.Poly.Basics.Poly c) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Power.Type.PowPoly c) (AERN2.Poly.Power.Type.PowPoly c)
instance AERN2.MP.Precision.HasPrecision c => AERN2.MP.Precision.HasPrecision (AERN2.Poly.Power.Type.PowPoly c)
instance AERN2.MP.Precision.CanSetPrecision c => AERN2.MP.Precision.CanSetPrecision (AERN2.Poly.Power.Type.PowPoly c)
instance AERN2.MP.Accuracy.HasAccuracy c => AERN2.MP.Accuracy.HasAccuracy (AERN2.Poly.Power.Type.PowPoly c)
instance GHC.Show.Show (AERN2.Poly.Basics.Poly c) => GHC.Show.Show (AERN2.Poly.Power.Type.PowPoly c)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Power.Type.PowPoly c0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Types.Int, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Power.Type.PowPoly c0) GHC.Types.Int
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Real.Rational, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Power.Type.PowPoly c0) GHC.Real.Rational
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Power.Type.PowPoly c0) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Power.Type.PowPoly c0) AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.AddSub.CanSubSameType c, Numeric.MixedTypes.Bool.CanNegSameType c, Numeric.MixedTypes.AddSub.CanAddSameType c) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Power.Type.PowPoly c) (AERN2.Poly.Power.Type.PowPoly c)
instance Numeric.MixedTypes.Bool.CanNegSameType c => Numeric.MixedTypes.Bool.CanNeg (AERN2.Poly.Power.Type.PowPoly c)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer (AERN2.Poly.Power.Type.PowPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Types.Int, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int (AERN2.Poly.Power.Type.PowPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Real.Rational, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational (AERN2.Poly.Power.Type.PowPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Poly.Power.Type.PowPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall (AERN2.Poly.Power.Type.PowPoly c0)
instance AERN2.MP.Enclosure.IsBall (AERN2.Poly.Power.Type.PowPoly AERN2.MP.Ball.Type.MPBall)
instance Numeric.MixedTypes.AddSub.CanAddSameType c => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Power.Type.PowPoly c) (AERN2.Poly.Power.Type.PowPoly c)

module AERN2.Poly.Power.Eval
evalDirect :: (CanAddAsymmetric b c, b ~ AddType b c, Ring b, HasIntegers b, HasIntegers c) => PowPoly c -> b -> b
evalMBI :: PowPoly MPBall -> MPBall -> MPBall
evalDI :: PowPoly MPBall -> MPBall -> MPBall
evalDf :: PowPoly MPBall -> PowPoly MPBall -> MPBall -> MPBall
evalDIn :: PowPoly MPBall -> MPBall -> Integer -> MPBall
evalLip :: PowPoly MPBall -> MPBall -> MPBall -> MPBall
markovBoundI :: PowPoly MPBall -> MPBall

module AERN2.Poly.Power.Roots
initialBernsteinCoefs :: PowPoly MPBall -> MPBall -> MPBall -> Terms MPBall
bernsteinCoefs :: MPBall -> MPBall -> MPBall -> Terms MPBall -> (Terms MPBall, Terms MPBall)
signVars :: Terms MPBall -> Maybe Integer
reflect :: PowPoly c -> PowPoly c
contract :: (CanMulSameType c, CanPow c Integer, PowType c Integer ~ c) => c -> PowPoly c -> PowPoly c
translate :: MPBall -> PowPoly MPBall -> PowPoly MPBall
transform :: MPBall -> MPBall -> PowPoly MPBall -> PowPoly MPBall
findRoots :: PowPoly MPBall -> MPBall -> MPBall -> ((MPBall, MPBall) -> Bool) -> [(MPBall, MPBall)]
type Terms c = Map Integer c
instance GHC.Classes.Eq AERN2.Poly.Power.Roots.HasRoot
instance AERN2.MP.Accuracy.HasAccuracy c => AERN2.MP.Accuracy.HasAccuracy (AERN2.Poly.Power.Roots.Terms c)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.Poly.Power.Roots.HasRoot AERN2.Poly.Power.Roots.HasRoot

module AERN2.Poly.Power.RootsIntMap
initialBernsteinCoefs :: PowPoly Integer -> ErrorBound -> Rational -> Rational -> Terms
bernsteinCoefs :: Rational -> Rational -> Rational -> Terms -> (Terms, Terms)
signVars :: Terms -> Maybe Integer
reflect :: PowPoly c -> PowPoly c
contract :: (CanMulSameType c, CanPow c Integer, PowType c Integer ~ c) => c -> PowPoly c -> PowPoly c
translate :: Integer -> PowPoly Integer -> PowPoly Integer
transform :: Integer -> Integer -> PowPoly Integer -> PowPoly Integer
reduce :: Terms -> Terms
type Terms = (ErrorBound, Integer, Map Integer Integer)
instance GHC.Classes.Eq AERN2.Poly.Power.RootsIntMap.HasRoot
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.Poly.Power.RootsIntMap.HasRoot AERN2.Poly.Power.RootsIntMap.HasRoot

module AERN2.Poly.Power.SignedSubresultantMap
type IntPoly = PowPoly Integer
separablePart :: IntPoly -> IntPoly
gcdAndgcdFreePart :: IntPoly -> IntPoly -> (IntPoly, IntPoly)
extendedSignedSubresultant :: IntPoly -> IntPoly -> (Map Integer IntPoly, Map Integer IntPoly, Map Integer IntPoly)
justLookup :: (Ord k, Show k, Show a) => k -> Map k a -> a
isZero :: IntPoly -> Bool
zero :: IntPoly
one :: IntPoly
coeff :: Integer -> IntPoly -> Integer
leadingCoefficient :: IntPoly -> Integer
sweepLeadingZeroes :: IntPoly -> IntPoly

-- | Quotient of Euclidean division. Only valid if result is again an
--   integer polynomial.
quo :: IntPoly -> IntPoly -> IntPoly
instance Numeric.MixedTypes.Field.CanDiv AERN2.Poly.Power.SignedSubresultantMap.IntPoly GHC.Integer.Type.Integer

module AERN2.Poly.Power.SignedSubresultantVector
type IntPoly = PowPoly Integer
separablePart :: IntPoly -> IntPoly
gcdAndgcdFreePart :: IntPoly -> IntPoly -> (IntPoly, IntPoly)
extendedSignedSubresultant :: IntPoly -> IntPoly -> (Map Integer IntPoly, Map Integer IntPoly, Map Integer IntPoly)
justLookup :: (Ord k, Show k, Show a) => k -> Map k a -> a
isZero :: IntPoly -> Bool
zero :: IntPoly
one :: IntPoly
coeff :: Integer -> IntPoly -> Integer
leadingCoefficient :: IntPoly -> Integer
sweepLeadingZeroes :: IntPoly -> IntPoly

-- | Quotient of Euclidean division. Only valid if result is again an
--   integer polynomial.
quo :: IntPoly -> IntPoly -> IntPoly
instance Numeric.MixedTypes.Field.CanDiv AERN2.Poly.Power.SignedSubresultantVector.IntPoly GHC.Integer.Type.Integer

module AERN2.Poly.Power.SignedSubresultant

module AERN2.Poly.Power.SizeReduction
reduceDegree :: PowPoly MPBall -> MPBall -> MPBall -> Integer -> PowPoly MPBall
reduceDegreeI :: PowPoly MPBall -> Integer -> PowPoly MPBall


-- | Unary sparse polynomials
module AERN2.Poly


-- | IntPSQ with simplified API, hiding the keys
module AERN2.PQueue
data PQueue p
null :: PQueue p -> Bool
size :: PQueue p -> Int
singleton :: (Ord p) => p -> PQueue p
empty :: (Ord p) => PQueue p
insert :: (Ord p) => p -> PQueue p -> PQueue p
minView :: (Ord p) => PQueue p -> Maybe (p, PQueue p)

module AERN2.Poly.Power.Maximum
genericMaximum :: (MPBall -> MPBall) -> Map Integer (MPBall -> MPBall, PowPoly MPBall) -> Accuracy -> MPBall -> MPBall -> MPBall
maximum :: PowPoly MPBall -> MPBall -> MPBall -> MPBall
maximumOptimised :: PowPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
maximumNaive :: PowPoly MPBall -> MPBall -> MPBall -> Rational -> MPBall
minimum :: PowPoly MPBall -> MPBall -> MPBall -> MPBall
minimumOptimised :: PowPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
minimumNaive :: PowPoly MPBall -> MPBall -> MPBall -> Rational -> MPBall
instance GHC.Show.Show AERN2.Poly.Power.Maximum.MaximisationInterval
instance GHC.Classes.Eq AERN2.Poly.Power.Maximum.MaximisationInterval
instance GHC.Classes.Ord AERN2.Poly.Power.Maximum.MaximisationInterval


-- | Power basis unary sparse polynomials
module AERN2.Poly.Power

module AERN2.Poly.Conversion
cheb2PowerExact :: Poly MPBall -> PowPoly MPBall
cheb2Power :: (CanMulSameType (PowPoly a), HasIntegers a, CanAddSameType a) => Poly a -> PowPoly a
recPowers :: (CanMulSameType (PowPoly a), HasIntegers a, CanAddSameType a) => [(PolyMat a)]
data PolyMat a
PolyMat :: (PowPoly a) -> (PowPoly a) -> (PowPoly a) -> (PowPoly a) -> PolyMat a
data PolyCoVec a
PolyCoVec :: (PowPoly a) -> (PowPoly a) -> PolyCoVec a
data PolyVec a
PolyVec :: (PowPoly a) -> (PowPoly a) -> PolyVec a
instance (Numeric.MixedTypes.Ring.CanMulSameType (AERN2.Poly.Power.Type.PowPoly a), Numeric.MixedTypes.AddSub.CanAddSameType a) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Conversion.PolyMat a) (AERN2.Poly.Conversion.PolyMat a)
instance (Numeric.MixedTypes.Ring.CanMulSameType (AERN2.Poly.Power.Type.PowPoly a), Numeric.MixedTypes.AddSub.CanAddSameType a) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Conversion.PolyCoVec a) (AERN2.Poly.Conversion.PolyMat a)
instance (Numeric.MixedTypes.Ring.CanMulSameType (AERN2.Poly.Power.Type.PowPoly a), Numeric.MixedTypes.AddSub.CanAddSameType a) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Conversion.PolyCoVec a) (AERN2.Poly.Conversion.PolyVec a)
instance Numeric.MixedTypes.AddSub.CanAddSameType a => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Conversion.PolyCoVec a) (AERN2.Poly.Conversion.PolyCoVec a)

module AERN2.Local.Basics
type Local a = Dyadic -> Dyadic -> Accuracy -> a
constant :: a -> Local a
liftLocal1 :: (a -> b) -> Local a -> Local b
liftLocal2 :: (a -> b -> c) -> Local a -> Local b -> Local c

module AERN2.Local.Field
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer a0 => Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Int a0 => Numeric.MixedTypes.Field.CanDiv GHC.Types.Int (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational a0 => Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic a0 => Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall a0 => Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.Field.CanDiv AERN2.Real.Type.CauchyReal a0 => Numeric.MixedTypes.Field.CanDiv AERN2.Real.Type.CauchyReal (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.Field.CanDiv a b => Numeric.MixedTypes.Field.CanDiv (AERN2.Local.Basics.Local a) (AERN2.Local.Basics.Local b)

module AERN2.Local.Ring
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer a0 => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a0 GHC.Integer.Type.Integer => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Local.Basics.Local a0) GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer a0 => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a0 GHC.Integer.Type.Integer => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Local.Basics.Local a0) GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer a0 => Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.AddSub.CanSub a0 GHC.Integer.Type.Integer => Numeric.MixedTypes.AddSub.CanSub (AERN2.Local.Basics.Local a0) GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int a0 => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a0 GHC.Types.Int => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Local.Basics.Local a0) GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int a0 => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a0 GHC.Types.Int => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Local.Basics.Local a0) GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int a0 => Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.AddSub.CanSub a0 GHC.Types.Int => Numeric.MixedTypes.AddSub.CanSub (AERN2.Local.Basics.Local a0) GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational a0 => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a0 GHC.Real.Rational => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Local.Basics.Local a0) GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational a0 => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a0 GHC.Real.Rational => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Local.Basics.Local a0) GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational a0 => Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.AddSub.CanSub a0 GHC.Real.Rational => Numeric.MixedTypes.AddSub.CanSub (AERN2.Local.Basics.Local a0) GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic a0 => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a0 AERN2.MP.Dyadic.Dyadic => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Local.Basics.Local a0) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic a0 => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a0 AERN2.MP.Dyadic.Dyadic => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Local.Basics.Local a0) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic a0 => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.AddSub.CanSub a0 AERN2.MP.Dyadic.Dyadic => Numeric.MixedTypes.AddSub.CanSub (AERN2.Local.Basics.Local a0) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall a0 => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a0 AERN2.MP.Ball.Type.MPBall => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Local.Basics.Local a0) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall a0 => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a0 AERN2.MP.Ball.Type.MPBall => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Local.Basics.Local a0) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall a0 => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.AddSub.CanSub a0 AERN2.MP.Ball.Type.MPBall => Numeric.MixedTypes.AddSub.CanSub (AERN2.Local.Basics.Local a0) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.Real.Type.CauchyReal a0 => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.Real.Type.CauchyReal (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a0 AERN2.Real.Type.CauchyReal => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Local.Basics.Local a0) AERN2.Real.Type.CauchyReal
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.Real.Type.CauchyReal a0 => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.Real.Type.CauchyReal (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a0 AERN2.Real.Type.CauchyReal => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Local.Basics.Local a0) AERN2.Real.Type.CauchyReal
instance Numeric.MixedTypes.AddSub.CanSub AERN2.Real.Type.CauchyReal a0 => Numeric.MixedTypes.AddSub.CanSub AERN2.Real.Type.CauchyReal (AERN2.Local.Basics.Local a0)
instance Numeric.MixedTypes.AddSub.CanSub a0 AERN2.Real.Type.CauchyReal => Numeric.MixedTypes.AddSub.CanSub (AERN2.Local.Basics.Local a0) AERN2.Real.Type.CauchyReal
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric a b => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Local.Basics.Local a) (AERN2.Local.Basics.Local b)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric a b => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Local.Basics.Local a) (AERN2.Local.Basics.Local b)
instance Numeric.MixedTypes.AddSub.CanSub a b => Numeric.MixedTypes.AddSub.CanSub (AERN2.Local.Basics.Local a) (AERN2.Local.Basics.Local b)
instance Numeric.MixedTypes.Bool.CanNeg a => Numeric.MixedTypes.Bool.CanNeg (AERN2.Local.Basics.Local a)


-- | Intervals for use as function domains
module AERN2.Interval
data Interval l r
Interval :: l -> r -> Interval l r
[endpointL] :: Interval l r -> l
[endpointR] :: Interval l r -> r
singleton :: a -> Interval a a
width :: (CanSub r l) => Interval l r -> SubType r l
split :: (CanAddSameType t, CanMulBy t Dyadic) => (Interval t t) -> (Interval t t, Interval t t)
arbitraryNonEmptyInterval :: (Arbitrary l, Arbitrary r, HasOrderCertainlyAsymmetric l r) => Gen (Interval l r)
arbitraryNonEmptySmallInterval :: (Arbitrary e, CanAddThis e Integer) => Gen (Interval e e)
intersect :: (CanMinMaxSameType l, CanMinMaxSameType r, HasOrderCertainly l r) => Interval l r -> Interval l r -> Maybe (Interval l r)
intersects :: (CanMinMaxSameType l, CanMinMaxSameType r, HasOrderCertainly l r) => Interval l r -> Interval l r -> Bool
type DyadicInterval = Interval Dyadic Dyadic
type CanBeDyadicInterval t = ConvertibleExactly t DyadicInterval
dyadicInterval :: (CanBeDyadicInterval t) => t -> DyadicInterval
type RealInterval = Interval CauchyReal CauchyReal
type CanBeRealInterval t = ConvertibleExactly t RealInterval
realInterval :: (CanBeRealInterval t) => t -> RealInterval
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric l0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Ord.OrderCompareType l0 GHC.Integer.Type.Integer ~ GHC.Types.Bool, Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer r0, Numeric.MixedTypes.Ord.OrderCompareType GHC.Integer.Type.Integer r0 ~ GHC.Types.Bool) => AERN2.MP.Enclosure.CanTestContains (AERN2.Interval.Interval l0 r0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric l0 GHC.Types.Int, Numeric.MixedTypes.Ord.OrderCompareType l0 GHC.Types.Int ~ GHC.Types.Bool, Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int r0, Numeric.MixedTypes.Ord.OrderCompareType GHC.Types.Int r0 ~ GHC.Types.Bool) => AERN2.MP.Enclosure.CanTestContains (AERN2.Interval.Interval l0 r0) GHC.Types.Int
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric l0 GHC.Real.Rational, Numeric.MixedTypes.Ord.OrderCompareType l0 GHC.Real.Rational ~ GHC.Types.Bool, Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational r0, Numeric.MixedTypes.Ord.OrderCompareType GHC.Real.Rational r0 ~ GHC.Types.Bool) => AERN2.MP.Enclosure.CanTestContains (AERN2.Interval.Interval l0 r0) GHC.Real.Rational
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric l0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Ord.OrderCompareType l0 AERN2.MP.Dyadic.Dyadic ~ GHC.Types.Bool, Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Dyadic.Dyadic r0, Numeric.MixedTypes.Ord.OrderCompareType AERN2.MP.Dyadic.Dyadic r0 ~ GHC.Types.Bool) => AERN2.MP.Enclosure.CanTestContains (AERN2.Interval.Interval l0 r0) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.AddSub.CanSubSameType e, Numeric.MixedTypes.Ring.CanAddSubMulBy t e, Numeric.MixedTypes.Round.HasIntegerBounds t, Numeric.MixedTypes.AddSub.CanSubThis t GHC.Integer.Type.Integer, Numeric.MixedTypes.Field.CanDivBy t GHC.Integer.Type.Integer) => AERN2.MP.Enclosure.CanMapInside (AERN2.Interval.Interval e e) t
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric l1 l2, Numeric.MixedTypes.Eq.HasEqAsymmetric r1 r2, Numeric.MixedTypes.Eq.EqCompareType l1 l2 ~ Numeric.MixedTypes.Eq.EqCompareType r1 r2, Numeric.MixedTypes.Bool.CanAndOrSameType (Numeric.MixedTypes.Eq.EqCompareType l1 l2)) => Numeric.MixedTypes.Eq.HasEqAsymmetric (AERN2.Interval.Interval l1 r1) (AERN2.Interval.Interval l2 r2)
instance (AERN2.MP.Dyadic.CanBeDyadic l, AERN2.MP.Dyadic.CanBeDyadic r, Numeric.MixedTypes.Ord.HasOrderCertainly l r, GHC.Show.Show l, GHC.Show.Show r, Data.Typeable.Internal.Typeable l, Data.Typeable.Internal.Typeable r) => Numeric.MixedTypes.Literals.ConvertibleExactly (l, r) AERN2.Interval.DyadicInterval
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Dyadic.Dyadic AERN2.Interval.DyadicInterval
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer AERN2.Interval.DyadicInterval
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Real.Rational AERN2.Interval.DyadicInterval
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Ball.Type.MPBall AERN2.Interval.DyadicInterval
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.Interval.DyadicInterval AERN2.MP.Ball.Type.MPBall
instance (AERN2.Real.Type.CanBeReal l, AERN2.Real.Type.CanBeReal r, Numeric.MixedTypes.Ord.HasOrderCertainly l r, GHC.Show.Show l, GHC.Show.Show r, Data.Typeable.Internal.Typeable l, Data.Typeable.Internal.Typeable r) => Numeric.MixedTypes.Literals.ConvertibleExactly (l, r) AERN2.Interval.RealInterval
instance GHC.Generics.Generic (AERN2.Interval.Interval l r)
instance (GHC.Classes.Eq r, GHC.Classes.Eq l) => GHC.Classes.Eq (AERN2.Interval.Interval l r)
instance (GHC.Show.Show l, GHC.Show.Show r) => GHC.Show.Show (AERN2.Interval.Interval l r)
instance (GHC.Read.Read l, GHC.Read.Read r) => GHC.Read.Read (AERN2.Interval.Interval l r)
instance AERN2.MP.Enclosure.IsInterval (AERN2.Interval.Interval e e) e
instance (Test.QuickCheck.Arbitrary.Arbitrary l, Test.QuickCheck.Arbitrary.Arbitrary r, Numeric.MixedTypes.Ord.HasOrderCertainlyAsymmetric l r) => Test.QuickCheck.Arbitrary.Arbitrary (AERN2.Interval.Interval l r)
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric l l', Numeric.MixedTypes.Ord.OrderCompareType l l' ~ GHC.Types.Bool, Numeric.MixedTypes.Ord.HasOrderAsymmetric r' r, Numeric.MixedTypes.Ord.OrderCompareType r' r ~ GHC.Types.Bool) => AERN2.MP.Enclosure.CanTestContains (AERN2.Interval.Interval l r) (AERN2.Interval.Interval l' r')

module AERN2.Poly.Power.RootsIntVector
initialBernsteinCoefs :: PowPoly Integer -> ErrorBound -> Rational -> Rational -> Terms
bernsteinCoefs :: Rational -> Rational -> Rational -> Terms -> (Terms, Terms)
signVars :: Terms -> Maybe Integer
reflect :: PowPoly c -> PowPoly c
contract :: (CanMulSameType c, CanPow c Integer, PowType c Integer ~ c) => c -> PowPoly c -> PowPoly c
translate :: Integer -> PowPoly Integer -> PowPoly Integer
transform :: Integer -> Integer -> PowPoly Integer -> PowPoly Integer
findRootsWithAccuracy :: PowPoly Integer -> Accuracy -> Rational -> Rational -> [Interval Rational Rational]
type Terms = (ErrorBound, Integer, Vector Integer)
instance GHC.Classes.Eq AERN2.Poly.Power.RootsIntVector.HasRoot
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.Poly.Power.RootsIntVector.HasRoot AERN2.Poly.Power.RootsIntVector.HasRoot

module AERN2.Poly.Power.RootsInt
initialBernsteinCoefs :: PowPoly Integer -> ErrorBound -> Rational -> Rational -> Terms
bernsteinCoefs :: Rational -> Rational -> Rational -> Terms -> (Terms, Terms)
signVars :: Terms -> Maybe Integer
reflect :: PowPoly c -> PowPoly c
contract :: (CanMulSameType c, CanPow c Integer, PowType c Integer ~ c) => c -> PowPoly c -> PowPoly c
translate :: Integer -> PowPoly Integer -> PowPoly Integer
transform :: Integer -> Integer -> PowPoly Integer -> PowPoly Integer
type Terms = (ErrorBound, Integer, Vector Integer)

module AERN2.Poly.Power.MaximumInt
genericMaximum :: (MPBall -> MPBall) -> Map Integer (MPBall -> MPBall, (ErrorBound, PowPoly Integer)) -> Accuracy -> MPBall -> MPBall -> MPBall
instance GHC.Show.Show AERN2.Poly.Power.MaximumInt.MaximisationInterval
instance GHC.Classes.Eq AERN2.Poly.Power.MaximumInt.MaximisationInterval
instance GHC.Classes.Ord AERN2.Poly.Power.MaximumInt.MaximisationInterval

module AERN2.Poly.Power.MaximumIntAlt
genericMaximum :: (MPBall -> MPBall) -> Map Integer (MPBall -> MPBall, (ErrorBound, PowPoly Integer)) -> Accuracy -> MPBall -> MPBall -> MPBall
genericMaximumWithBounds :: (MPBall -> MPBall) -> Map Integer (MPBall -> MPBall, (ErrorBound, PowPoly Integer)) -> Accuracy -> MPBall -> MPBall -> MPBall -> MPBall -> MPBall
instance GHC.Show.Show AERN2.Poly.Power.MaximumIntAlt.MaximisationInterval
instance GHC.Classes.Eq AERN2.Poly.Power.MaximumIntAlt.MaximisationInterval
instance GHC.Classes.Ord AERN2.Poly.Power.MaximumIntAlt.MaximisationInterval


-- | Classes for real number function operations
module AERN2.RealFun.Operations
class HasDomain f where type Domain f where {
    type family Domain f;
}
getDomain :: HasDomain f => f -> Domain f
data SameDomFnPair f
SameDomFnPair :: (f, f) -> SameDomFnPair f
class (HasDomain f) => ArbitraryWithDom f
arbitraryWithDom :: ArbitraryWithDom f => (Domain f) -> Gen f
class CanApply f x where type ApplyType f x where {
    type family ApplyType f x;
}

-- | compute <tt>f(x)</tt>
apply :: CanApply f x => f -> x -> ApplyType f x

-- | Give an unsafe etimate of the function's range which is fast to
--   compute. Intended to be used in optimisation heuristics.
class CanApplyApprox f x where type ApplyApproxType f x where {
    type family ApplyApproxType f x;
}

-- | compute a cheap and unsafe approximation of <tt>f(x)</tt>
applyApprox :: CanApplyApprox f x => f -> x -> ApplyApproxType f x

-- | Evaluate a function on a regular grid of the given size and return the
--   largerst and smallest values found. Useful for making instances of
--   class <a>CanApplyApprox</a>.
sampledRange :: (CanApply f t, ApplyType f t ~ t, CanMinMaxSameType t, ConvertibleExactly Dyadic t, Show t) => DyadicInterval -> Integer -> f -> Interval t t
class HasVars f where type Var f where {
    type family Var f;
}

-- | the function <tt>x</tt>, ie the function that project the domain to
--   the given variable <tt>x</tt>
varFn :: HasVars f => f -> Var f -> f
specEvalUnaryVarFn :: (HasVars f, Var f ~ (), HasDomain f, CanMapInside (Domain f) x, CanApply f x, HasEqCertainly x (ApplyType f x), Arbitrary f, Arbitrary x, Show f, Show x) => T f -> T x -> Spec
type HasConstFunctions t f = (HasDomain f, ConvertibleExactly (Domain f, t) f)
constFn :: (HasConstFunctions t f) => (Domain f, t) -> f
specEvalConstFn :: (HasConstFunctions c f, CanMapInside (Domain f) x, CanApply f x, HasEqCertainly c (ApplyType f x), Arbitrary c, Arbitrary f, Arbitrary x, Show c, Show f, Show x) => T c -> T f -> T x -> Spec
class CanMaximiseOverDom f d where type MaximumOverDomType f d where {
    type family MaximumOverDomType f d;
}
maximumOverDom :: CanMaximiseOverDom f d => f -> d -> MaximumOverDomType f d
class CanMinimiseOverDom f d where type MinimumOverDomType f d where {
    type family MinimumOverDomType f d;
}
minimumOverDom :: CanMinimiseOverDom f d => f -> d -> MinimumOverDomType f d
specCanMaximiseOverDom :: (HasDomain f, CanMapInside (Domain f) x, CanApply f x, ApplyType f x ~ v, CanMaximiseOverDom f (Domain f), HasOrderCertainly v (MaximumOverDomType f (Domain f)), Arbitrary f, Show f, Arbitrary x, Show x) => (T f) -> (T x) -> Spec
class CanIntegrateOverDom f bounds where type IntegralOverDomType f bounds where {
    type family IntegralOverDomType f bounds;
}
integrateOverDom :: CanIntegrateOverDom f bounds => f -> bounds -> IntegralOverDomType f bounds
instance GHC.Show.Show f => GHC.Show.Show (AERN2.RealFun.Operations.SameDomFnPair f)
instance (AERN2.RealFun.Operations.ArbitraryWithDom f, Test.QuickCheck.Arbitrary.Arbitrary f) => Test.QuickCheck.Arbitrary.Arbitrary (AERN2.RealFun.Operations.SameDomFnPair f)

module AERN2.Local.Integration
instance (AERN2.RealFun.Operations.CanIntegrateOverDom f AERN2.Interval.DyadicInterval, c ~ AERN2.RealFun.Operations.IntegralOverDomType f AERN2.Interval.DyadicInterval, Numeric.MixedTypes.Literals.HasIntegers c, Numeric.MixedTypes.AddSub.CanAddSameType c, Numeric.MixedTypes.Ring.CanMul AERN2.MP.Dyadic.Dyadic c, Numeric.MixedTypes.Ring.MulType AERN2.MP.Dyadic.Dyadic c ~ c) => AERN2.RealFun.Operations.CanIntegrateOverDom (AERN2.Local.Basics.Local f) AERN2.Interval.DyadicInterval


-- | Chebyshev basis unary sparse polynomials
module AERN2.Poly.Cheb.Type
type ChPolyMB = ChPoly MPBall
data ChPoly c
ChPoly :: DyadicInterval -> Poly c -> Maybe (ChPolyBounds c) -> ChPoly c
[chPoly_dom] :: ChPoly c -> DyadicInterval
[chPoly_poly] :: ChPoly c -> Poly c
[chPoly_maybeBounds] :: ChPoly c -> Maybe (ChPolyBounds c)
chPoly_terms :: ChPoly c -> Terms c
data ChPolyBounds c
ChPolyBounds :: c -> ChPolyBounds c
[chPolyBounds_lip] :: ChPolyBounds c -> c
chPoly_maybeLip :: ChPoly c -> Maybe c
chPoly_setLip :: c -> ChPoly c -> ChPoly c
type CanBeChPoly c t = ConvertibleExactly t (ChPoly c)
chPoly :: (CanBeChPoly c t) => t -> (ChPoly c)
chPolyMPBall :: (ConvertibleExactly t (ChPoly MPBall)) => t -> ChPoly MPBall
showInternals :: (Show c) => ChPoly c -> String
fromDomToUnitInterval :: (CanAddSubMulDivBy t Dyadic) => DyadicInterval -> t -> t
serialise :: ChPolyMB -> String
deserialise :: ByteString -> Maybe ChPolyMB
type Degree = Integer
degree :: ChPoly c -> Integer

-- | Drop all terms that whose degree is above the given limit or whose
--   norm is at or below the threshold. Compensate for the drops in the
--   constant term.
reduceDegree :: (PolyCoeffBall c) => Degree -> ChPoly c -> ChPoly c
reduceDegreeWithLostAccuracyLimit :: (PolyCoeffBall c) => Accuracy -> ChPoly c -> ChPoly c
instance GHC.Show.Show c => GHC.Show.Show (AERN2.Poly.Cheb.Type.ChPolyBounds c)
instance GHC.Show.Show (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall)
instance AERN2.RealFun.Operations.HasDomain (AERN2.Poly.Cheb.Type.ChPoly c)
instance (AERN2.MP.Enclosure.IsBall c, Numeric.MixedTypes.Literals.HasIntegers c) => AERN2.MP.Enclosure.IsBall (AERN2.Poly.Cheb.Type.ChPoly c)
instance AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall)
instance AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly GHC.Integer.Type.Integer)
instance AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly GHC.Real.Rational)
instance AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Dyadic.Dyadic)
instance (AERN2.MP.Dyadic.HasDyadics c, Numeric.MixedTypes.Literals.HasIntegers c) => AERN2.RealFun.Operations.HasVars (AERN2.Poly.Cheb.Type.ChPoly c)
instance (Numeric.MixedTypes.Literals.ConvertibleExactly t c, Numeric.MixedTypes.Literals.HasIntegers c) => Numeric.MixedTypes.Literals.ConvertibleExactly (AERN2.Interval.DyadicInterval, t) (AERN2.Poly.Cheb.Type.ChPoly c)
instance (Numeric.MixedTypes.Literals.ConvertibleExactly t c, Numeric.MixedTypes.Literals.HasIntegers c) => Numeric.MixedTypes.Literals.ConvertibleExactly (AERN2.Poly.Cheb.Type.ChPoly c, t) (AERN2.Poly.Cheb.Type.ChPoly c)
instance AERN2.MP.Precision.HasPrecision c => AERN2.MP.Precision.HasPrecision (AERN2.Poly.Cheb.Type.ChPoly c)
instance (AERN2.MP.Precision.CanSetPrecision c, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c)) => AERN2.MP.Precision.CanSetPrecision (AERN2.Poly.Cheb.Type.ChPoly c)
instance (AERN2.MP.Accuracy.HasAccuracy c, Numeric.MixedTypes.Literals.HasIntegers c, AERN2.MP.Enclosure.IsBall c) => AERN2.MP.Accuracy.HasAccuracy (AERN2.Poly.Cheb.Type.ChPoly c)
instance AERN2.Poly.Basics.PolyCoeffBall c => AERN2.MP.Accuracy.CanReduceSizeUsingAccuracyGuide (AERN2.Poly.Cheb.Type.ChPoly c)


-- | Interpolation using Discrete cosine transform
module AERN2.Poly.Cheb.DCT

-- | DCT-approximate the result of applying the given function <tt>f</tt>
--   pointwise to the given polynomial <tt>p</tt>.
lift1_DCT :: (Field c, CanMulBy c CauchyReal, CanNormalize (ChPoly c), Show c) => (Degree -> Degree) -> (c -> c) -> ChPoly c -> ChPoly c

-- | DCT-approximate the result of applying the given binary function
--   <tt>f</tt> pointwise to the given polynomials <tt>p1</tt> and
--   <tt>p2</tt>.
lift2_DCT :: (PolyCoeffBall c, CanNormalize (ChPoly c)) => (Degree -> Degree -> Degree) -> (c -> c -> c) -> ChPoly c -> ChPoly c -> ChPoly c


-- | Chebyshev basis ring operations
module AERN2.Poly.Cheb.Ring
mulCheb :: (PolyCoeffBall c, CanNormalize (ChPoly c)) => (ChPoly c) -> (ChPoly c) -> (ChPoly c)
mulChebDirect :: (PolyCoeffRing c, CanMulBy c Dyadic, CanNormalize (ChPoly c)) => (ChPoly c) -> (ChPoly c) -> (ChPoly c)
mulChebDCT :: (PolyCoeffBall c, CanNormalize (ChPoly c)) => (ChPoly c) -> (ChPoly c) -> (ChPoly c)
instance (Numeric.MixedTypes.Field.CanDivBy c0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.Field.CanDivBy c0 GHC.Types.Int, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Types.Int
instance (Numeric.MixedTypes.Field.CanDivBy c0 GHC.Real.Rational, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Real.Rational
instance (Numeric.MixedTypes.Field.CanDivBy c0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.Field.CanDivBy c0 AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.Field.CanDivBy c0 AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.Real.Type.CauchyReal
instance (Numeric.MixedTypes.Ring.CanMulBy c0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.Ring.CanMulBy c0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.Ring.CanMulBy c0 GHC.Types.Int, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.Ring.CanMulBy c0 GHC.Types.Int, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Types.Int
instance (Numeric.MixedTypes.Ring.CanMulBy c0 GHC.Real.Rational, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.Ring.CanMulBy c0 GHC.Real.Rational, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Real.Rational
instance (Numeric.MixedTypes.Ring.CanMulBy c0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.Ring.CanMulBy c0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.Ring.CanMulBy c0 AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.Ring.CanMulBy c0 AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.Ring.CanMulBy c0 AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.Real.Type.CauchyReal (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.Ring.CanMulBy c0 AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.Literals.HasIntegers c0, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.Real.Type.CauchyReal
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Bool.CanNegSameType c0, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Types.Int, Numeric.MixedTypes.Bool.CanNegSameType c0, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Types.Int, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Types.Int
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Real.Rational, Numeric.MixedTypes.Bool.CanNegSameType c0, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Real.Rational, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Real.Rational
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Bool.CanNegSameType c0, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.Bool.CanNegSameType c0, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.Bool.CanNegSameType c0, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub AERN2.Real.Type.CauchyReal (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.Real.Type.CauchyReal
instance c ~ AERN2.MP.Ball.Type.MPBall => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Cheb.Type.ChPoly c) (AERN2.Poly.Cheb.Type.ChPoly c)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Cheb.Type.ChPoly GHC.Real.Rational) (AERN2.Poly.Cheb.Type.ChPoly GHC.Real.Rational)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Dyadic.Dyadic) (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Dyadic.Dyadic)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Types.Int, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Types.Int, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Types.Int
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Real.Rational, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 GHC.Real.Rational, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Real.Rational
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.Real.Type.CauchyReal (AERN2.Poly.Cheb.Type.ChPoly c0)
instance (Numeric.MixedTypes.AddSub.CanAddThis c0 AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.Literals.HasIntegers c0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.Real.Type.CauchyReal
instance (AERN2.Poly.Basics.PolyCoeffRing c, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c)) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Cheb.Type.ChPoly c) (AERN2.Poly.Cheb.Type.ChPoly c)
instance Numeric.MixedTypes.Bool.CanNegSameType c => Numeric.MixedTypes.Bool.CanNeg (AERN2.Poly.Cheb.Type.ChPoly c)
instance (AERN2.Poly.Basics.PolyCoeffRing c, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Cheb.Type.ChPoly c) (AERN2.Poly.Cheb.Type.ChPoly c)


-- | Chebyshev basis derivative
module AERN2.Poly.Cheb.Derivative
derivativeExact :: ChPoly MPBall -> ChPoly MPBall

-- | the following definition is here only to check this typechecks
derivativeRational :: ChPoly Rational -> ChPoly Rational
derivative :: (PolyCoeffRing c, CanMulBy (ChPoly c) c, CanDivBy c Dyadic, CanNormalize (ChPoly c)) => ChPoly c -> ChPoly c
derivativeI :: (PolyCoeffRing c, CanMulBy (ChPoly c) c, CanMulBy c Dyadic, CanNormalize (ChPoly c)) => ChPoly c -> ChPoly c
derivative' :: (PolyCoeffRing c, CanMulBy (ChPoly c) c, CanDivBy c Dyadic, CanNormalize (ChPoly c)) => ChPoly c -> ChPoly c


-- | Chebyshev basis integration
module AERN2.Poly.Cheb.Integration
primitive_function :: (Ring c, CanDivBy c Integer, CanNormalize (ChPoly c), CanMulBy c Dyadic) => ChPoly c -> ChPoly c
instance (Numeric.MixedTypes.Ring.Ring c, Numeric.MixedTypes.Field.CanDivBy c GHC.Integer.Type.Integer, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly c), AERN2.Poly.Basics.PolyCoeffBall c, AERN2.RealFun.Operations.CanApply (AERN2.Poly.Cheb.Type.ChPoly c) c, AERN2.RealFun.Operations.ApplyType (AERN2.Poly.Cheb.Type.ChPoly c) c ~ c) => AERN2.RealFun.Operations.CanIntegrateOverDom (AERN2.Poly.Cheb.Type.ChPoly c) AERN2.Interval.DyadicInterval


-- | Pointwise sine and cosine for functions
module AERN2.RealFun.SineCosine
sineWithAccuracyGuide :: (HasDomain f, CanApplyApprox f (Domain f), ConvertibleExactly (ApplyApproxType f (Domain f)) MPBall, CanNegSameType f, CanAddSameType f, CanMulSameType f, CanAddSubMulDivBy f Integer, CanAddSubMulDivBy f CauchyReal, HasAccuracy f, CanSetPrecision f, CanReduceSizeUsingAccuracyGuide f, IsBall f, Show f) => Accuracy -> f -> f
cosineWithAccuracyGuide :: (HasDomain f, CanApplyApprox f (Domain f), ConvertibleExactly (ApplyApproxType f (Domain f)) MPBall, CanNegSameType f, CanAddSameType f, CanMulSameType f, CanAddSubMulDivBy f Integer, CanAddSubMulDivBy f CauchyReal, HasAccuracy f, CanSetPrecision f, CanReduceSizeUsingAccuracyGuide f, IsBall f, Show f) => Accuracy -> f -> f
sineCosineWithAccuracyGuide :: (HasDomain f, CanApplyApprox f (Domain f), ConvertibleExactly (ApplyApproxType f (Domain f)) MPBall, CanNegSameType f, CanAddSameType f, CanMulSameType f, CanAddSubMulDivBy f Integer, CanAddSubMulDivBy f CauchyReal, HasAccuracy f, CanSetPrecision f, CanReduceSizeUsingAccuracyGuide f, IsBall f, Show f) => Bool -> Accuracy -> f -> f

-- | For a given polynomial <tt>p</tt>, compute a partial Taylor sum of
--   <tt>cos(p)</tt> and return it together with its error bound <tt>e</tt>
--   and the degree of the polynomial <tt>n</tt>.
sineTaylorSum :: (CanAddSameType f, CanMulSameType f, CanAddSubMulDivBy f Integer, HasAccuracy f, CanSetPrecision f, CanReduceSizeUsingAccuracyGuide f, Show f) => (Accuracy -> f) -> MPBall -> Accuracy -> (f, ErrorBound, Integer)

-- | For a given polynomial <tt>p</tt>, compute a partial Taylor sum of
--   <tt>cos(p)</tt> and return it together with its error bound <tt>e</tt>
--   and the degree of the polynomial <tt>n</tt>.
cosineTaylorSum :: (CanAddSameType f, CanMulSameType f, CanAddSubMulDivBy f Integer, HasAccuracy f, CanSetPrecision f, CanReduceSizeUsingAccuracyGuide f, Show f) => (Accuracy -> f) -> MPBall -> Accuracy -> (f, ErrorBound, Integer)
sineCosineTaylorSum :: (CanAddSameType f, CanMulSameType f, CanAddSubMulDivBy f Integer, HasAccuracy f, CanSetPrecision f, CanReduceSizeUsingAccuracyGuide f, Show f) => Bool -> (Accuracy -> f) -> MPBall -> Accuracy -> (f, ErrorBound, Integer)

module AERN2.Local.SineCosine
sineLocal :: (HasDomain f, CanApplyApprox f (Domain f), ConvertibleExactly (ApplyApproxType f (Domain f)) MPBall, CanNegSameType f, CanAddSameType f, CanMulSameType f, CanAddSubMulDivBy f Integer, CanAddSubMulDivBy f CauchyReal, HasAccuracy f, CanSetPrecision f, CanReduceSizeUsingAccuracyGuide f, IsBall f, Show f) => Local f -> Local f
cosineLocal :: (HasDomain f, CanApplyApprox f (Domain f), ConvertibleExactly (ApplyApproxType f (Domain f)) MPBall, CanNegSameType f, CanAddSameType f, CanMulSameType f, CanAddSubMulDivBy f Integer, CanAddSubMulDivBy f CauchyReal, HasAccuracy f, CanSetPrecision f, CanReduceSizeUsingAccuracyGuide f, IsBall f, Show f) => Local f -> Local f


-- | Test support for real number function operations
module AERN2.RealFun.Tests
data FnAndDescr f
FnAndDescr :: f -> String -> FnAndDescr f
specFnPointwiseOp1 :: (HasDomain f, CanMapInside (Domain f) x, CanApply f x, ApplyType f x ~ v, HasEqCertainly v v, Arbitrary (FnAndDescr f), ArbitraryWithDom (FnAndDescr f), Show f, Arbitrary x, Show x) => (T f) -> (T x) -> String -> (f -> f) -> (CatchingNumExceptions v -> CatchingNumExceptions v) -> (FnAndDescr f -> FnAndDescr f) -> Spec
specFnPointwiseOp2 :: (HasDomain f, CanMapInside (Domain f) x, CanApply f x, ApplyType f x ~ v, HasEqCertainly v v, Arbitrary (FnAndDescr f), ArbitraryWithDom (FnAndDescr f), Show f, Arbitrary x, Show x) => (T f) -> (T x) -> String -> (f -> f -> f) -> (CatchingNumExceptions v -> CatchingNumExceptions v -> CatchingNumExceptions v) -> (FnAndDescr f -> FnAndDescr f) -> (FnAndDescr f -> FnAndDescr f) -> Spec
instance GHC.Show.Show f => GHC.Show.Show (AERN2.RealFun.Tests.FnAndDescr f)
instance AERN2.RealFun.Operations.HasDomain f => AERN2.RealFun.Operations.HasDomain (AERN2.RealFun.Tests.FnAndDescr f)


-- | Type definitions and basics.
module AERN2.RealFun.UnaryBallFun.Type
data UnaryBallFun
UnaryBallFun :: DyadicInterval -> (CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall) -> UnaryBallFun
[unaryBallFun_Domain] :: UnaryBallFun -> DyadicInterval

-- | For convergent sequence of *open* balls the resulting sequence should
--   also converge.
[unaryBallFun_Eval] :: UnaryBallFun -> CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall
unaryBallFun :: (CanBeUnaryBallFun t) => t -> UnaryBallFun
instance AERN2.RealFun.Operations.HasDomain AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun
instance (AERN2.MP.Ball.Type.CanBeMPBall t, GHC.Show.Show t, Data.Typeable.Internal.Typeable t) => Numeric.MixedTypes.Literals.ConvertibleExactly (AERN2.Interval.DyadicInterval, t) AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun
instance AERN2.RealFun.Operations.HasVars AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun


-- | Evaluation and range computation
module AERN2.RealFun.UnaryBallFun.Evaluation
evalOnIntervalGuessPrecision :: (CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall) -> (DyadicInterval -> CatchingNumExceptions MPBall)
minimumOnIntervalSubdivide :: (DyadicInterval -> (Maybe (CatchingNumExceptions MPBall, CatchingNumExceptions MPBall), CatchingNumExceptions MPBall)) -> (DyadicInterval -> CauchyReal)
maximumOnIntervalSubdivide :: (DyadicInterval -> (Maybe (CatchingNumExceptions MPBall, CatchingNumExceptions MPBall), CatchingNumExceptions MPBall)) -> (DyadicInterval -> CauchyReal)
rangeOnIntervalSubdivide :: (DyadicInterval -> (Maybe (CatchingNumExceptions MPBall, CatchingNumExceptions MPBall), CatchingNumExceptions MPBall)) -> (DyadicInterval -> RealInterval)
instance GHC.Show.Show AERN2.RealFun.UnaryBallFun.Evaluation.MaxSearchSegment
instance AERN2.RealFun.Operations.CanApply AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun AERN2.MP.Ball.Type.MPBall
instance AERN2.RealFun.Operations.CanApply AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun (Numeric.CatchingExceptions.Type.CatchingNumExceptions AERN2.MP.Ball.Type.MPBall)
instance AERN2.QA.QAArrow to => AERN2.RealFun.Operations.CanApply AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun (AERN2.Real.Type.CauchyRealA to)
instance AERN2.RealFun.Operations.CanApply AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun GHC.Integer.Type.Integer
instance AERN2.RealFun.Operations.CanApply AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun GHC.Types.Int
instance AERN2.RealFun.Operations.CanApply AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun AERN2.MP.Dyadic.Dyadic
instance AERN2.RealFun.Operations.CanApply AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun AERN2.Interval.DyadicInterval
instance AERN2.RealFun.Operations.CanMaximiseOverDom AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun AERN2.Interval.DyadicInterval
instance AERN2.RealFun.Operations.CanMinimiseOverDom AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun AERN2.Interval.DyadicInterval
instance GHC.Classes.Eq AERN2.RealFun.UnaryBallFun.Evaluation.MaxSearchSegment
instance GHC.Classes.Ord AERN2.RealFun.UnaryBallFun.Evaluation.MaxSearchSegment


-- | Unary function integration
module AERN2.RealFun.UnaryBallFun.Integration
integralOnIntervalSubdivide :: (s -> DyadicInterval -> Accuracy -> (s, CatchingNumExceptions MPBall)) -> s -> (DyadicInterval -> CauchyReal)
integralOnIntervalIncreasePrecision :: (DyadicInterval -> Precision -> CatchingNumExceptions MPBall) -> [Precision] -> DyadicInterval -> Accuracy -> ([Precision], CatchingNumExceptions MPBall)
instance AERN2.RealFun.Operations.CanIntegrateOverDom AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun AERN2.Interval.DyadicInterval


-- | Real functions by MPBall evaluators, including derivatives
module AERN2.RealFun.UnaryBallDFun
data UnaryBallDFun
UnaryBallDFun :: [UnaryBallFun] -> UnaryBallDFun
[_dballfun_derivatives] :: UnaryBallDFun -> [UnaryBallFun]
instance AERN2.RealFun.Operations.CanApply AERN2.RealFun.UnaryBallDFun.UnaryBallDFun AERN2.Interval.DyadicInterval
instance AERN2.RealFun.Operations.CanMaximiseOverDom AERN2.RealFun.UnaryBallDFun.UnaryBallDFun AERN2.Interval.DyadicInterval
instance AERN2.RealFun.Operations.CanMinimiseOverDom AERN2.RealFun.UnaryBallDFun.UnaryBallDFun AERN2.Interval.DyadicInterval
instance AERN2.RealFun.Operations.CanIntegrateOverDom AERN2.RealFun.UnaryBallDFun.UnaryBallDFun AERN2.Interval.DyadicInterval


-- | Real functions represented by MPBall evaluators
module AERN2.RealFun.UnaryBallFun
data UnaryBallFun
UnaryBallFun :: DyadicInterval -> (CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall) -> UnaryBallFun
[unaryBallFun_Domain] :: UnaryBallFun -> DyadicInterval

-- | For convergent sequence of *open* balls the resulting sequence should
--   also converge.
[unaryBallFun_Eval] :: UnaryBallFun -> CatchingNumExceptions MPBall -> CatchingNumExceptions MPBall
unaryBallFun :: (CanBeUnaryBallFun t) => t -> UnaryBallFun


-- | Evaluation and range
module AERN2.Poly.Cheb.Eval
evalDirect :: (Ring t, CanAddSubMulDivBy t Dyadic, CanDivBy t Integer, CanAddSubMulBy t c, Ring c) => (ChPoly c) -> t -> t
evalLip :: ChPoly MPBall -> MPBall -> MPBall -> MPBall
evalDf :: ChPoly MPBall -> ChPoly MPBall -> MPBall -> MPBall
evalLDf :: ChPoly MPBall -> ChPoly MPBall -> MPBall -> MPBall
evalDI :: ChPoly MPBall -> MPBall -> MPBall
reduceToEvalDirectAccuracy :: ChPoly MPBall -> Accuracy -> ChPoly MPBall
evalDirectWithAccuracy :: Accuracy -> ChPoly MPBall -> MPBall -> MPBall
instance (Numeric.MixedTypes.Ring.CanAddSubMulBy AERN2.MP.Ball.Type.MPBall c, Numeric.MixedTypes.Ring.Ring c, c ~ AERN2.MP.Ball.Type.MPBall) => AERN2.RealFun.Operations.CanApply (AERN2.Poly.Cheb.Type.ChPoly c) AERN2.MP.Ball.Type.MPBall
instance AERN2.RealFun.Operations.CanApply (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall) (Numeric.CatchingExceptions.Type.CatchingNumExceptions AERN2.MP.Ball.Type.MPBall)
instance AERN2.RealFun.Operations.CanApplyApprox (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall) AERN2.Interval.DyadicInterval
instance Numeric.MixedTypes.Literals.ConvertibleExactly (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall) (AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun, AERN2.MP.ErrorBound.ErrorBound)

module AERN2.Poly.Cheb.MaximumInt
maximum :: ChPoly MPBall -> MPBall -> MPBall -> MPBall
maximumWithAccuracy :: Accuracy -> ChPoly MPBall -> MPBall -> MPBall -> MPBall
maximumOptimised :: ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
maximumOptimisedWithAccuracy :: Accuracy -> ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
minimum :: ChPoly MPBall -> MPBall -> MPBall -> MPBall
minimumOptimised :: ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
minimumOptimisedWithAccuracy :: Accuracy -> ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
maximumOptimisedWithAccuracyAndBounds :: Accuracy -> ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall -> MPBall -> MPBall
instance AERN2.RealFun.Operations.CanMinimiseOverDom (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall) AERN2.Interval.DyadicInterval
instance AERN2.RealFun.Operations.CanMaximiseOverDom (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall) AERN2.Interval.DyadicInterval

module AERN2.Poly.Cheb.Maximum
maximum :: ChPoly MPBall -> MPBall -> MPBall -> MPBall
maximumOptimised :: ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
maximumOptimisedWithAccuracy :: Accuracy -> ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
minimum :: ChPoly MPBall -> MPBall -> MPBall -> MPBall
minimumOptimised :: ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
minimumOptimisedWithAccuracy :: Accuracy -> ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall


-- | Poly division and integer power
module AERN2.Poly.Cheb.Field
chebDivideDCT :: (c ~ MPBall) => Accuracy -> ChPoly c -> ChPoly c -> ChPoly c
maxNorm :: (r ~ MaximumOverDomType f (Domain f), r ~ MinimumOverDomType f (Domain f), CanAbsSameType r, CanMinMaxSameType r, CanMaximiseOverDom f (Domain f), CanMinimiseOverDom f (Domain f), HasDomain f) => f -> r
sepFromZero :: (r ~ MaximumOverDomType f (Domain f), r ~ MinimumOverDomType f (Domain f), CanNegSameType r, CanMinMaxSameType r, CanMaximiseOverDom f (Domain f), CanMinimiseOverDom f (Domain f), HasDomain f) => f -> r
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall)
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Int (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall)
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall)
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall)
instance Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall) (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall)


-- | Chebyshev basis unary sparse polynomials
module AERN2.Poly.Cheb
_chPolyX :: ChPoly MPBall
_chPoly10X :: ChPoly MPBall
_chPolySineX :: Accuracy -> ChPoly MPBall
_chPolySine10X :: Accuracy -> ChPoly MPBall
_chPolyCosine10X :: Accuracy -> ChPoly MPBall

module AERN2.Local.Maximum
class GenericMaximum a
genericise :: GenericMaximum a => a -> GenFun
genericise :: GenericMaximum a => a -> GenFun
maximum :: (GenericMaximum a) => a -> MPBall -> MPBall -> Accuracy -> MPBall
minimum :: (GenericMaximum a, CanNegSameType a) => a -> MPBall -> MPBall -> Accuracy -> MPBall
instance GHC.Classes.Eq AERN2.Local.Maximum.MaximisationInterval
instance GHC.Classes.Ord AERN2.Local.Maximum.MaximisationInterval

module AERN2.Local

module AERN2.Local.Poly
variable :: LocalPoly MPBall
genericisePoly :: ChPoly MPBall -> Dyadic -> Dyadic -> (Dyadic, Dyadic, MPBall -> MPBall, Accuracy, Rational -> Rational, DyadicInterval, Terms)
type LocalPoly a = Local (ChPoly a)
instance AERN2.Local.Maximum.GenericMaximum (AERN2.Local.Poly.LocalPoly AERN2.MP.Ball.Type.MPBall)


-- | Polynomial enclosures with large radii
module AERN2.Poly.Ball
_pb_const1 :: PolyBall
_pb_X :: PolyBall
type PolyBall = Ball (ChPoly MPBall)
polyBall :: (ConvertibleExactly t PolyBall) => t -> PolyBall
data Ball t
Ball :: t -> ErrorBound -> Ball t
[ball_value] :: Ball t -> t
[ball_radius] :: Ball t -> ErrorBound
ballLift1R :: (IsBall t) => (t -> t1) -> (Ball t -> t1)
ballLift1TR :: (IsBall t) => (t -> t1 -> t2) -> (Ball t -> t1 -> t2)
ballLift1T :: (IsBall t) => (t -> t1 -> t) -> (Ball t -> t1 -> Ball t)
ballLift2 :: (IsBall t) => (t -> t -> t) -> (Ball t -> Ball t -> Ball t)
multiplyWithBounds :: PolyBall -> MPBall -> PolyBall -> MPBall -> PolyBall
multiplyAccurate :: PolyBall -> PolyBall -> PolyBall
multiplyWithAccuracy :: Accuracy -> PolyBall -> PolyBall -> PolyBall
instance (Numeric.MixedTypes.Field.CanDivBy t0 GHC.Integer.Type.Integer, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Ball.Ball t0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.Field.CanDivBy t0 GHC.Types.Int, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Ball.Ball t0) GHC.Types.Int
instance (Numeric.MixedTypes.Field.CanDivBy t0 GHC.Real.Rational, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Ball.Ball t0) GHC.Real.Rational
instance (Numeric.MixedTypes.Field.CanDivBy t0 AERN2.MP.Dyadic.Dyadic, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Ball.Ball t0) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.Field.CanDivBy t0 AERN2.MP.Ball.Type.MPBall, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Ball.Ball t0) AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.Field.CanDivBy t0 AERN2.Real.Type.CauchyReal, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Field.CanDiv (AERN2.Poly.Ball.Ball t0) AERN2.Real.Type.CauchyReal
instance AERN2.RealFun.Operations.CanApply AERN2.Poly.Ball.PolyBall AERN2.MP.Ball.Type.MPBall
instance AERN2.RealFun.Operations.CanApplyApprox AERN2.Poly.Ball.PolyBall AERN2.Interval.DyadicInterval
instance AERN2.RealFun.Operations.CanMaximiseOverDom AERN2.Poly.Ball.PolyBall AERN2.Interval.DyadicInterval
instance AERN2.RealFun.Operations.CanMinimiseOverDom AERN2.Poly.Ball.PolyBall AERN2.Interval.DyadicInterval
instance AERN2.RealFun.Operations.CanIntegrateOverDom AERN2.Poly.Ball.PolyBall AERN2.Interval.DyadicInterval
instance (Numeric.MixedTypes.Ring.CanMulBy t0 GHC.Integer.Type.Integer, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer (AERN2.Poly.Ball.Ball t0)
instance (Numeric.MixedTypes.Ring.CanMulBy t0 GHC.Integer.Type.Integer, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Ball.Ball t0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.Ring.CanMulBy t0 GHC.Types.Int, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int (AERN2.Poly.Ball.Ball t0)
instance (Numeric.MixedTypes.Ring.CanMulBy t0 GHC.Types.Int, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Ball.Ball t0) GHC.Types.Int
instance (Numeric.MixedTypes.Ring.CanMulBy t0 GHC.Real.Rational, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational (AERN2.Poly.Ball.Ball t0)
instance (Numeric.MixedTypes.Ring.CanMulBy t0 GHC.Real.Rational, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Ball.Ball t0) GHC.Real.Rational
instance (Numeric.MixedTypes.Ring.CanMulBy t0 AERN2.MP.Dyadic.Dyadic, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Poly.Ball.Ball t0)
instance (Numeric.MixedTypes.Ring.CanMulBy t0 AERN2.MP.Dyadic.Dyadic, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Ball.Ball t0) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.Ring.CanMulBy t0 AERN2.MP.Ball.Type.MPBall, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall (AERN2.Poly.Ball.Ball t0)
instance (Numeric.MixedTypes.Ring.CanMulBy t0 AERN2.MP.Ball.Type.MPBall, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Ball.Ball t0) AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.Ring.CanMulBy t0 AERN2.Real.Type.CauchyReal, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.Real.Type.CauchyReal (AERN2.Poly.Ball.Ball t0)
instance (Numeric.MixedTypes.Ring.CanMulBy t0 AERN2.Real.Type.CauchyReal, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Ball.Ball t0) AERN2.Real.Type.CauchyReal
instance (AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0, Numeric.MixedTypes.AddSub.CanAddThis t0 GHC.Integer.Type.Integer, Numeric.MixedTypes.Bool.CanNegSameType t0) => Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer (AERN2.Poly.Ball.Ball t0)
instance (AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0, Numeric.MixedTypes.AddSub.CanAddThis t0 GHC.Integer.Type.Integer) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Ball.Ball t0) GHC.Integer.Type.Integer
instance (AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0, Numeric.MixedTypes.AddSub.CanAddThis t0 GHC.Types.Int, Numeric.MixedTypes.Bool.CanNegSameType t0) => Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int (AERN2.Poly.Ball.Ball t0)
instance (AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0, Numeric.MixedTypes.AddSub.CanAddThis t0 GHC.Types.Int) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Ball.Ball t0) GHC.Types.Int
instance (AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0, Numeric.MixedTypes.AddSub.CanAddThis t0 GHC.Real.Rational, Numeric.MixedTypes.Bool.CanNegSameType t0) => Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational (AERN2.Poly.Ball.Ball t0)
instance (AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0, Numeric.MixedTypes.AddSub.CanAddThis t0 GHC.Real.Rational) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Ball.Ball t0) GHC.Real.Rational
instance (AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0, Numeric.MixedTypes.AddSub.CanAddThis t0 AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Bool.CanNegSameType t0) => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic (AERN2.Poly.Ball.Ball t0)
instance (AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0, Numeric.MixedTypes.AddSub.CanAddThis t0 AERN2.MP.Dyadic.Dyadic) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Ball.Ball t0) AERN2.MP.Dyadic.Dyadic
instance (AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0, Numeric.MixedTypes.AddSub.CanAddThis t0 AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.Bool.CanNegSameType t0) => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall (AERN2.Poly.Ball.Ball t0)
instance (AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0, Numeric.MixedTypes.AddSub.CanAddThis t0 AERN2.MP.Ball.Type.MPBall) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Ball.Ball t0) AERN2.MP.Ball.Type.MPBall
instance (AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0, Numeric.MixedTypes.AddSub.CanAddThis t0 AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.Bool.CanNegSameType t0) => Numeric.MixedTypes.AddSub.CanSub AERN2.Real.Type.CauchyReal (AERN2.Poly.Ball.Ball t0)
instance (AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0, Numeric.MixedTypes.AddSub.CanAddThis t0 AERN2.Real.Type.CauchyReal) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Ball.Ball t0) AERN2.Real.Type.CauchyReal
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.Poly.Ball.PolyBall AERN2.Poly.Ball.PolyBall
instance (Numeric.MixedTypes.AddSub.CanAddThis t0 GHC.Integer.Type.Integer, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer (AERN2.Poly.Ball.Ball t0)
instance (Numeric.MixedTypes.AddSub.CanAddThis t0 GHC.Integer.Type.Integer, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Ball.Ball t0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.AddSub.CanAddThis t0 GHC.Types.Int, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int (AERN2.Poly.Ball.Ball t0)
instance (Numeric.MixedTypes.AddSub.CanAddThis t0 GHC.Types.Int, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Ball.Ball t0) GHC.Types.Int
instance (Numeric.MixedTypes.AddSub.CanAddThis t0 GHC.Real.Rational, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational (AERN2.Poly.Ball.Ball t0)
instance (Numeric.MixedTypes.AddSub.CanAddThis t0 GHC.Real.Rational, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Ball.Ball t0) GHC.Real.Rational
instance (Numeric.MixedTypes.AddSub.CanAddThis t0 AERN2.MP.Dyadic.Dyadic, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Poly.Ball.Ball t0)
instance (Numeric.MixedTypes.AddSub.CanAddThis t0 AERN2.MP.Dyadic.Dyadic, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Ball.Ball t0) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.AddSub.CanAddThis t0 AERN2.MP.Ball.Type.MPBall, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall (AERN2.Poly.Ball.Ball t0)
instance (Numeric.MixedTypes.AddSub.CanAddThis t0 AERN2.MP.Ball.Type.MPBall, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Ball.Ball t0) AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.AddSub.CanAddThis t0 AERN2.Real.Type.CauchyReal, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.Real.Type.CauchyReal (AERN2.Poly.Ball.Ball t0)
instance (Numeric.MixedTypes.AddSub.CanAddThis t0 AERN2.Real.Type.CauchyReal, AERN2.MP.Enclosure.IsBall t0, AERN2.Normalize.CanNormalize t0) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Ball.Ball t0) AERN2.Real.Type.CauchyReal
instance (AERN2.MP.Enclosure.IsBall t, AERN2.Normalize.CanNormalize t, Numeric.MixedTypes.AddSub.CanAddSameType t, Numeric.MixedTypes.Bool.CanNegSameType t) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Poly.Ball.Ball t) (AERN2.Poly.Ball.Ball t)
instance GHC.Show.Show t => GHC.Show.Show (AERN2.Poly.Ball.Ball t)
instance AERN2.MP.Enclosure.IsBall t => AERN2.MP.Enclosure.IsBall (AERN2.Poly.Ball.Ball t)
instance (AERN2.MP.Enclosure.IsBall t, AERN2.Normalize.CanNormalize t) => AERN2.Normalize.CanNormalize (AERN2.Poly.Ball.Ball t)
instance Numeric.MixedTypes.Literals.ConvertibleExactly (AERN2.Interval.DyadicInterval, t2) t => Numeric.MixedTypes.Literals.ConvertibleExactly (AERN2.Interval.DyadicInterval, t2) (AERN2.Poly.Ball.Ball t)
instance Numeric.MixedTypes.Literals.ConvertibleExactly (t, t2) t => Numeric.MixedTypes.Literals.ConvertibleExactly (AERN2.Poly.Ball.Ball t, t2) (AERN2.Poly.Ball.Ball t)
instance AERN2.RealFun.Operations.HasDomain t => AERN2.RealFun.Operations.HasDomain (AERN2.Poly.Ball.Ball t)
instance AERN2.RealFun.Operations.HasVars t => AERN2.RealFun.Operations.HasVars (AERN2.Poly.Ball.Ball t)
instance (AERN2.MP.Precision.HasPrecision t, AERN2.MP.Enclosure.IsBall t) => AERN2.MP.Precision.HasPrecision (AERN2.Poly.Ball.Ball t)
instance (AERN2.MP.Precision.CanSetPrecision t, AERN2.MP.Enclosure.IsBall t) => AERN2.MP.Precision.CanSetPrecision (AERN2.Poly.Ball.Ball t)
instance (AERN2.MP.Accuracy.HasAccuracy t, AERN2.MP.Enclosure.IsBall t) => AERN2.MP.Accuracy.HasAccuracy (AERN2.Poly.Ball.Ball t)
instance (AERN2.MP.Enclosure.IsBall t, AERN2.Normalize.CanNormalize t, AERN2.MP.Accuracy.CanReduceSizeUsingAccuracyGuide t) => AERN2.MP.Accuracy.CanReduceSizeUsingAccuracyGuide (AERN2.Poly.Ball.Ball t)
instance Numeric.MixedTypes.Bool.CanNegSameType t => Numeric.MixedTypes.Bool.CanNeg (AERN2.Poly.Ball.Ball t)
instance (AERN2.MP.Enclosure.IsBall t, AERN2.Normalize.CanNormalize t, Numeric.MixedTypes.AddSub.CanAddSameType t) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Poly.Ball.Ball t) (AERN2.Poly.Ball.Ball t)

module AERN2.PPoly.Type
type Cheb = ChPoly MPBall
data PPoly
PPoly :: [(DyadicInterval, PolyBall)] -> DyadicInterval -> PPoly
[ppoly_pieces] :: PPoly -> [(DyadicInterval, PolyBall)]
[ppoly_dom] :: PPoly -> DyadicInterval
ppoly_degree :: PPoly -> Integer
fromPoly :: Cheb -> PPoly
fromPolyBall :: PolyBall -> PPoly
linearPolygonI :: [(Dyadic, MPBall)] -> DyadicInterval -> PPoly
liftBall2PPoly :: (PolyBall -> PolyBall) -> (PPoly -> PPoly)
liftCheb2PPoly :: (Cheb -> Cheb) -> (PPoly -> PPoly)
refine :: PPoly -> PPoly -> [(DyadicInterval, PolyBall, PolyBall)]
intersectionAndDifference :: (DyadicInterval, PolyBall) -> (DyadicInterval, PolyBall) -> (Bool, (DyadicInterval, PolyBall, PolyBall), Maybe (DyadicInterval, PolyBall))
multiplyWithBounds :: PPoly -> MPBall -> PPoly -> MPBall -> PPoly
instance AERN2.RealFun.Operations.HasDomain AERN2.PPoly.Type.PPoly
instance AERN2.MP.Enclosure.IsBall AERN2.PPoly.Type.PPoly
instance AERN2.MP.Accuracy.HasAccuracy AERN2.PPoly.Type.PPoly
instance AERN2.MP.Precision.HasPrecision AERN2.PPoly.Type.PPoly
instance AERN2.MP.Precision.CanSetPrecision AERN2.PPoly.Type.PPoly
instance GHC.Show.Show AERN2.PPoly.Type.PPoly
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.PPoly.Type.PPoly AERN2.PPoly.Type.PPoly
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.PPoly.Type.PPoly AERN2.PPoly.Type.PPoly
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.PPoly.Type.Cheb AERN2.PPoly.Type.PPoly
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.PPoly.Type.PPoly AERN2.PPoly.Type.Cheb
instance Numeric.MixedTypes.Bool.CanNeg AERN2.PPoly.Type.PPoly
instance Numeric.MixedTypes.AddSub.CanSub AERN2.PPoly.Type.PPoly AERN2.PPoly.Type.PPoly
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.PPoly.Type.PPoly GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub AERN2.PPoly.Type.PPoly GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer AERN2.PPoly.Type.PPoly
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer AERN2.PPoly.Type.PPoly
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.PPoly.Type.PPoly GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer AERN2.PPoly.Type.PPoly
instance Numeric.MixedTypes.Field.CanDiv AERN2.PPoly.Type.PPoly GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.PPoly.Type.PPoly AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall AERN2.PPoly.Type.PPoly
instance Numeric.MixedTypes.AddSub.CanSub AERN2.PPoly.Type.PPoly AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.PPoly.Type.PPoly
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.PPoly.Type.PPoly AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.PPoly.Type.PPoly
instance Numeric.MixedTypes.Field.CanDiv AERN2.PPoly.Type.PPoly AERN2.MP.Ball.Type.MPBall

module AERN2.Local.PPoly
type LocalPPoly = Local PPoly
fromPoly :: LocalPoly MPBall -> LocalPPoly
makeRational :: ChPoly MPBall -> ChPoly Rational
instance AERN2.Local.Maximum.GenericMaximum AERN2.Local.PPoly.LocalPPoly

module AERN2.PPoly.Eval
evalDirect :: PPoly -> MPBall -> MPBall
evalDirectWithAccuracy :: Accuracy -> PPoly -> MPBall -> MPBall
evalDf :: PPoly -> [ChPoly MPBall] -> MPBall -> MPBall
evalLDf :: PPoly -> [ChPoly MPBall] -> MPBall -> MPBall
evalDI :: PPoly -> MPBall -> MPBall
instance AERN2.RealFun.Operations.CanApply AERN2.PPoly.Type.PPoly AERN2.MP.Ball.Type.MPBall
instance AERN2.RealFun.Operations.CanApply AERN2.PPoly.Type.PPoly (Numeric.CatchingExceptions.Type.CatchingNumExceptions AERN2.MP.Ball.Type.MPBall)
instance AERN2.RealFun.Operations.CanApplyApprox AERN2.PPoly.Type.PPoly AERN2.Interval.DyadicInterval

module AERN2.PPoly.Integration
integral :: PPoly -> MPBall -> MPBall -> MPBall
instance AERN2.RealFun.Operations.CanIntegrateOverDom AERN2.PPoly.Type.PPoly AERN2.Interval.DyadicInterval

module AERN2.PPoly.Maximum
minimum :: PPoly -> MPBall -> MPBall -> MPBall
minimumOptimised :: PPoly -> MPBall -> MPBall -> Integer -> Integer -> MPBall
minimumOptimisedWithAccuracy :: PPoly -> MPBall -> MPBall -> Integer -> Integer -> Accuracy -> MPBall
maximumOptimisedWithAccuracySimple :: PPoly -> MPBall -> MPBall -> Integer -> Integer -> Accuracy -> MPBall
maximumOptimisedWithAccuracyAndDerivedBounds :: PPoly -> MPBall -> MPBall -> Integer -> Integer -> Accuracy -> MPBall
maximumOptimisedWithAccuracyAndBounds :: PPoly -> MPBall -> MPBall -> Integer -> Integer -> Accuracy -> MPBall -> MPBall -> MPBall
maximumOptimisedWithAccuracy :: PPoly -> MPBall -> MPBall -> Integer -> Integer -> Accuracy -> MPBall
maximumOptimisedWithAccuracy' :: PPoly -> MPBall -> MPBall -> Integer -> Integer -> Accuracy -> MPBall
maximumOptimised :: PPoly -> MPBall -> MPBall -> Integer -> Integer -> MPBall
maximum :: PPoly -> MPBall -> MPBall -> MPBall
genericMaximum :: (MPBall -> MPBall) -> Map (Integer, Integer) (MPBall -> MPBall, (ErrorBound, PowPoly Integer)) -> Map Integer Integer -> [MPBall] -> Map Integer Accuracy -> MPBall
data MaximisationInterval
SearchInterval :: Rational -> Rational -> MPBall -> (Maybe MPBall) -> (Integer, Integer) -> Terms -> MaximisationInterval
CriticalInterval :: Rational -> Rational -> MPBall -> (Maybe MPBall) -> (Integer, Integer) -> Integer -> MaximisationInterval
FinalInterval :: Rational -> Rational -> MPBall -> MaximisationInterval
mi_left :: MaximisationInterval -> Rational
mi_right :: MaximisationInterval -> Rational
mi_isFinal :: MaximisationInterval -> Bool
mi_value :: MaximisationInterval -> MPBall
mi_oldValue :: MaximisationInterval -> Maybe MPBall
mi_derivative :: MaximisationInterval -> (Integer, Integer)
mi_isAccurate :: MaximisationInterval -> Accuracy -> Integer -> Bool
isMoreAccurate :: MPBall -> Maybe MPBall -> Bool
computeMidpoint :: Rational -> Rational -> Rational
iterateUntilFixed :: (HasAccuracy t, HasPrecision t, CanSetPrecision t) => (t -> t) -> t -> t
intify :: ChPoly MPBall -> (ErrorBound, Poly Integer)
instance GHC.Show.Show AERN2.PPoly.Maximum.MaximisationInterval
instance GHC.Classes.Eq AERN2.PPoly.Maximum.MaximisationInterval
instance GHC.Classes.Ord AERN2.PPoly.Maximum.MaximisationInterval

module AERN2.PPoly.Division
inverse :: PPoly -> PPoly
inverseWithAccuracy :: Accuracy -> PPoly -> PPoly
initialApproximation :: PPoly -> Integer -> Accuracy -> PPoly
instance GHC.Classes.Eq AERN2.PPoly.Division.LineSegment
instance Numeric.MixedTypes.Field.CanDiv AERN2.PPoly.Type.PPoly AERN2.PPoly.Type.PPoly
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer AERN2.PPoly.Type.PPoly
instance GHC.Classes.Ord AERN2.PPoly.Division.LineSegment


-- | Unary piece-wise sparse polynomials
module AERN2.PPoly


-- | Tests for Chebyshev-basis polynomials
--   
--   To run the tests using stack, execute:
--   
--   <pre>
--   stack test aern2-fun --test-arguments "-a 100 -m ChPoly"
--   
--   </pre>
module AERN2.PPoly.Tests
data PPolyConstruction
PPolyConstruction :: Accuracy -> DyadicInterval -> FnIndex -> [(OpIndex, [FnIndex])] -> PPolyConstruction
[ppConstr_acGuide] :: PPolyConstruction -> Accuracy
[ppConstr_dom] :: PPolyConstruction -> DyadicInterval
[ppConstr_i0] :: PPolyConstruction -> FnIndex
[ppConstr_opIndices] :: PPolyConstruction -> [(OpIndex, [FnIndex])]
pPolyFromOps :: PPolyConstruction -> PPoly
pPolyFromOpsWithDeg :: Integer -> PPolyConstruction -> (PPoly, PPolyConstruction)
type OpIndex = Integer
type Arity = Integer
operations :: [(Arity, [PPoly] -> PPoly)]
type FnIndex = Integer
type Frequency = Integer
basicFunctions :: DyadicInterval -> [(Frequency, PPoly)]
arbitraryWithMinOpsDom :: Integer -> DyadicInterval -> Gen PPolyConstruction
arbitraryWithDegDom :: Integer -> DyadicInterval -> Gen (PPoly, PPolyConstruction)

-- | A runtime representative of type <tt>ChPoly MPBall</tt>. Used for
--   specialising polymorphic tests to concrete types.
tPPoly :: T PPoly
anyFn :: FnAndDescr PPoly -> FnAndDescr PPoly
makeFnPositive :: FnAndDescr PPoly -> FnAndDescr PPoly
makeFnSmallRange :: Integer -> FnAndDescr PPoly -> FnAndDescr PPoly
makeFnPositiveSmallRange :: Integer -> FnAndDescr PPoly -> FnAndDescr PPoly
specChPoly :: Spec
generate :: IO ()
test1 :: PPoly
instance GHC.Show.Show AERN2.PPoly.Tests.PPolyConstruction
instance AERN2.RealFun.Operations.HasDomain AERN2.PPoly.Tests.PPolyConstruction
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.PPoly.Tests.PPolyConstruction
instance AERN2.RealFun.Operations.ArbitraryWithDom AERN2.PPoly.Tests.PPolyConstruction
instance Test.QuickCheck.Arbitrary.Arbitrary (AERN2.RealFun.Tests.FnAndDescr AERN2.PPoly.Type.PPoly)
instance AERN2.RealFun.Operations.ArbitraryWithDom (AERN2.RealFun.Tests.FnAndDescr AERN2.PPoly.Type.PPoly)
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.PPoly.Type.PPoly

module AERN2.Poly.Cheb.MaximumMP
maximum :: ChPoly MPBall -> MPBall -> MPBall -> MPBall
maximumOptimised :: ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
maximumOptimisedWithAccuracy :: Accuracy -> ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
minimum :: ChPoly MPBall -> MPBall -> MPBall -> MPBall
minimumOptimised :: ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
minimumOptimisedWithAccuracy :: Accuracy -> ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
instance AERN2.RealFun.Operations.CanMinimiseOverDom (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall) AERN2.Interval.DyadicInterval
instance AERN2.RealFun.Operations.CanMaximiseOverDom (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall) AERN2.Interval.DyadicInterval

module AERN2.Poly.Cheb.MaximumPrime
maximum :: ChPoly MPBall -> MPBall -> MPBall -> MPBall
maximumOptimised :: ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
maximumOptimisedWithAccuracy :: Accuracy -> ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
minimum :: ChPoly MPBall -> MPBall -> MPBall -> MPBall
minimumOptimised :: ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
minimumOptimisedWithAccuracy :: Accuracy -> ChPoly MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
instance GHC.Show.Show AERN2.Poly.Cheb.MaximumPrime.MaximisationInterval
instance GHC.Classes.Eq AERN2.Poly.Cheb.MaximumPrime.MaximisationInterval
instance GHC.Classes.Ord AERN2.Poly.Cheb.MaximumPrime.MaximisationInterval
instance AERN2.RealFun.Operations.CanMinimiseOverDom (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall) AERN2.Interval.DyadicInterval
instance AERN2.RealFun.Operations.CanMaximiseOverDom (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall) AERN2.Interval.DyadicInterval


-- | Tests for Chebyshev-basis polynomials
--   
--   To run the tests using stack, execute:
--   
--   <pre>
--   stack test aern2-fun --test-arguments "-a 100 -m ChPoly"
--   
--   </pre>
module AERN2.Poly.Cheb.Tests
specChPoly :: Spec

-- | A runtime representative of type <tt>ChPoly MPBall</tt>. Used for
--   specialising polymorphic tests to concrete types.
tChPolyMPBall :: T (ChPoly MPBall)
data ChPolyConstruction
ChPolyConstruction :: Accuracy -> DyadicInterval -> FnIndex -> [(OpIndex, [FnIndex])] -> ChPolyConstruction
[cpConstr_acGuide] :: ChPolyConstruction -> Accuracy
[cpConstr_dom] :: ChPolyConstruction -> DyadicInterval
[cpConstr_i0] :: ChPolyConstruction -> FnIndex
[cpConstr_opIndices] :: ChPolyConstruction -> [(OpIndex, [FnIndex])]
chPolyFromOps :: ChPolyConstruction -> ChPolyMB
chPolyFromOpsWithDeg :: Integer -> ChPolyConstruction -> (ChPolyMB, ChPolyConstruction)
arbitraryWithMinOpsDom :: Integer -> DyadicInterval -> Gen ChPolyConstruction
arbitraryWithDegDom :: Integer -> DyadicInterval -> Gen (ChPolyMB, ChPolyConstruction)
makeFnPositive :: FnAndDescr (ChPoly MPBall) -> FnAndDescr (ChPoly MPBall)
makeFnSmallRange :: Integer -> FnAndDescr (ChPoly MPBall) -> FnAndDescr (ChPoly MPBall)
makeFnPositiveSmallRange :: Integer -> FnAndDescr (ChPoly MPBall) -> FnAndDescr (ChPoly MPBall)
instance GHC.Show.Show AERN2.Poly.Cheb.Tests.ChPolyConstruction
instance AERN2.RealFun.Operations.HasDomain AERN2.Poly.Cheb.Tests.ChPolyConstruction
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.Poly.Cheb.Tests.ChPolyConstruction
instance AERN2.RealFun.Operations.ArbitraryWithDom AERN2.Poly.Cheb.Tests.ChPolyConstruction
instance Test.QuickCheck.Arbitrary.Arbitrary (AERN2.RealFun.Tests.FnAndDescr (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall))
instance AERN2.RealFun.Operations.ArbitraryWithDom (AERN2.RealFun.Tests.FnAndDescr (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall))
instance Test.QuickCheck.Arbitrary.Arbitrary (AERN2.Poly.Cheb.Type.ChPoly AERN2.MP.Ball.Type.MPBall)


-- | Real functions by evaluator on dyadic points and a modulus of
--   continuity
module AERN2.RealFun.UnaryModFun

-- | Here we represent a continuous function &lt;math&gt; using its
--   evaluation function on dyadics and a "local" modulus of continuity
--   &lt;math&gt; in the following sense: . For any dyadic &lt;math&gt;
--   with &lt;math&gt; we have &lt;math&gt;.
--   
--   For any &lt;math&gt;, the modulus of continuity has to be a
--   non-decreasing function: &lt;math&gt; and &lt;math&gt; has to converge
--   to &lt;math&gt; with increasing &lt;math&gt;.
data UnaryModFun
UnaryModFun :: DyadicInterval -> (CatchingNumExceptions Dyadic -> CatchingNumExceptions CauchyReal) -> (MPBall -> Integer -> Integer) -> UnaryModFun
[_modfun_domain] :: UnaryModFun -> DyadicInterval

-- | \(d mapsto f(d)\)
[_modfun_eval] :: UnaryModFun -> CatchingNumExceptions Dyadic -> CatchingNumExceptions CauchyReal

-- | \(omega\)
[_modfun_modulus] :: UnaryModFun -> MPBall -> Integer -> Integer
unaryModFun :: (ConvertibleExactly t UnaryModFun) => t -> UnaryModFun

-- | For a monotone integer function &lt;math&gt;, and an integer
--   &lt;math&gt; which is neither below or above the range of
--   &lt;math&gt;, return the largest &lt;math&gt; such that &lt;math&gt;.
inverseNonDecreasingFnAnyBelow :: (Integer -> Integer) -> (Integer -> Integer)

-- | For a monotone integer function &lt;math&gt;, and an integer
--   &lt;math&gt; which is neither below or above the range of
--   &lt;math&gt;, return the largest &lt;math&gt; such that &lt;math&gt;.
inverseNonDecreasingFnMaxBelow :: (Integer -> Integer) -> (Integer -> Integer)
instance AERN2.RealFun.Operations.HasDomain AERN2.RealFun.UnaryModFun.UnaryModFun
instance Numeric.MixedTypes.Literals.ConvertibleExactly (AERN2.Interval.DyadicInterval, GHC.Integer.Type.Integer) AERN2.RealFun.UnaryModFun.UnaryModFun
instance AERN2.RealFun.Operations.HasVars AERN2.RealFun.UnaryModFun.UnaryModFun
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.RealFun.UnaryModFun.UnaryModFun AERN2.RealFun.UnaryBallFun.Type.UnaryBallFun
instance AERN2.RealFun.Operations.CanApply AERN2.RealFun.UnaryModFun.UnaryModFun AERN2.MP.Ball.Type.MPBall
instance AERN2.RealFun.Operations.CanApply AERN2.RealFun.UnaryModFun.UnaryModFun AERN2.Interval.DyadicInterval
instance AERN2.RealFun.Operations.CanMaximiseOverDom AERN2.RealFun.UnaryModFun.UnaryModFun AERN2.Interval.DyadicInterval
instance AERN2.RealFun.Operations.CanMinimiseOverDom AERN2.RealFun.UnaryModFun.UnaryModFun AERN2.Interval.DyadicInterval
instance AERN2.RealFun.Operations.CanIntegrateOverDom AERN2.RealFun.UnaryModFun.UnaryModFun AERN2.Interval.DyadicInterval
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.RealFun.UnaryModFun.UnaryModFun AERN2.RealFun.UnaryModFun.UnaryModFun
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer AERN2.RealFun.UnaryModFun.UnaryModFun
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.RealFun.UnaryModFun.UnaryModFun GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.RealFun.UnaryModFun.UnaryModFun AERN2.RealFun.UnaryModFun.UnaryModFun
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer AERN2.RealFun.UnaryModFun.UnaryModFun
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.RealFun.UnaryModFun.UnaryModFun GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Field.CanDiv AERN2.RealFun.UnaryModFun.UnaryModFun AERN2.RealFun.UnaryModFun.UnaryModFun
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer AERN2.RealFun.UnaryModFun.UnaryModFun
instance Numeric.MixedTypes.Elementary.CanSinCos AERN2.RealFun.UnaryModFun.UnaryModFun

module AERN2.Frac.Type
data Frac a
Frac :: ChPoly a -> ChPoly a -> a -> Frac a
[frac_numerator] :: Frac a -> ChPoly a
[frac_denominator] :: Frac a -> ChPoly a
[frac_dIM] :: Frac a -> a
degree :: Frac a -> Integer
fracLift1 :: (HasIntegers a) => (Frac a -> b) -> ChPoly a -> b
fracLift2 :: (HasIntegers a) => (Frac a -> Frac a -> b) -> (ChPoly a -> ChPoly a -> b)
fromPoly :: (HasIntegers a) => ChPoly a -> Frac a
_fracX :: Frac MPBall
instance GHC.Show.Show (AERN2.Poly.Cheb.Type.ChPoly a) => GHC.Show.Show (AERN2.Frac.Type.Frac a)
instance AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly a) => AERN2.Normalize.CanNormalize (AERN2.Frac.Type.Frac a)
instance AERN2.MP.Enclosure.IsBall (AERN2.Frac.Type.Frac a) => AERN2.MP.Accuracy.HasAccuracy (AERN2.Frac.Type.Frac a)
instance AERN2.MP.Precision.HasPrecision a => AERN2.MP.Precision.HasPrecision (AERN2.Frac.Type.Frac a)
instance (AERN2.MP.Precision.CanSetPrecision a, AERN2.Normalize.CanNormalize (AERN2.Poly.Cheb.Type.ChPoly a)) => AERN2.MP.Precision.CanSetPrecision (AERN2.Frac.Type.Frac a)
instance AERN2.RealFun.Operations.HasDomain (AERN2.Frac.Type.Frac a)
instance AERN2.MP.Enclosure.IsBall (AERN2.Frac.Type.Frac AERN2.MP.Ball.Type.MPBall)
instance AERN2.MP.Accuracy.CanReduceSizeUsingAccuracyGuide (AERN2.Frac.Type.Frac AERN2.MP.Ball.Type.MPBall)

module AERN2.Frac.Ring
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Integer.Type.Integer, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer (AERN2.Frac.Type.Frac c0)
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Integer.Type.Integer, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Frac.Type.Frac c0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Integer.Type.Integer, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Frac.Type.Frac c0) GHC.Integer.Type.Integer
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Integer.Type.Integer, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0), Numeric.MixedTypes.Bool.CanNegSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer (AERN2.Frac.Type.Frac c0)
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Types.Int, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int (AERN2.Frac.Type.Frac c0)
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Types.Int, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Frac.Type.Frac c0) GHC.Types.Int
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Types.Int, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Frac.Type.Frac c0) GHC.Types.Int
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Types.Int, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0), Numeric.MixedTypes.Bool.CanNegSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int (AERN2.Frac.Type.Frac c0)
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Real.Rational, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational (AERN2.Frac.Type.Frac c0)
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Real.Rational, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Frac.Type.Frac c0) GHC.Real.Rational
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Real.Rational, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Frac.Type.Frac c0) GHC.Real.Rational
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Real.Rational, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0), Numeric.MixedTypes.Bool.CanNegSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational (AERN2.Frac.Type.Frac c0)
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Frac.Type.Frac c0)
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Frac.Type.Frac c0) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Frac.Type.Frac c0) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0), Numeric.MixedTypes.Bool.CanNegSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic (AERN2.Frac.Type.Frac c0)
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall (AERN2.Frac.Type.Frac c0)
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Frac.Type.Frac c0) AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Frac.Type.Frac c0) AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Ball.Type.MPBall, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0), Numeric.MixedTypes.Bool.CanNegSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall (AERN2.Frac.Type.Frac c0)
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.Real.Type.CauchyReal (AERN2.Frac.Type.Frac c0)
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Frac.Type.Frac c0) AERN2.Real.Type.CauchyReal
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanSub (AERN2.Frac.Type.Frac c0) AERN2.Real.Type.CauchyReal
instance (Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.Real.Type.CauchyReal, Numeric.MixedTypes.AddSub.CanAddSameType (AERN2.Poly.Cheb.Type.ChPoly c0), Numeric.MixedTypes.Bool.CanNegSameType (AERN2.Poly.Cheb.Type.ChPoly c0)) => Numeric.MixedTypes.AddSub.CanSub AERN2.Real.Type.CauchyReal (AERN2.Frac.Type.Frac c0)
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Integer.Type.Integer => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer (AERN2.Frac.Type.Frac c0)
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Integer.Type.Integer => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Frac.Type.Frac c0) GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Integer.Type.Integer => Numeric.MixedTypes.Field.CanDiv (AERN2.Frac.Type.Frac c0) GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Types.Int => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int (AERN2.Frac.Type.Frac c0)
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Types.Int => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Frac.Type.Frac c0) GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Types.Int => Numeric.MixedTypes.Field.CanDiv (AERN2.Frac.Type.Frac c0) GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Real.Rational => Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational (AERN2.Frac.Type.Frac c0)
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Real.Rational => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Frac.Type.Frac c0) GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) GHC.Real.Rational => Numeric.MixedTypes.Field.CanDiv (AERN2.Frac.Type.Frac c0) GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Dyadic.Dyadic => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic (AERN2.Frac.Type.Frac c0)
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Dyadic.Dyadic => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Frac.Type.Frac c0) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Dyadic.Dyadic => Numeric.MixedTypes.Field.CanDiv (AERN2.Frac.Type.Frac c0) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Ball.Type.MPBall => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall (AERN2.Frac.Type.Frac c0)
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Ball.Type.MPBall => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Frac.Type.Frac c0) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.MP.Ball.Type.MPBall => Numeric.MixedTypes.Field.CanDiv (AERN2.Frac.Type.Frac c0) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.Real.Type.CauchyReal => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.Real.Type.CauchyReal (AERN2.Frac.Type.Frac c0)
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.Real.Type.CauchyReal => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Frac.Type.Frac c0) AERN2.Real.Type.CauchyReal
instance Numeric.MixedTypes.Ring.CanMulBy (AERN2.Poly.Cheb.Type.ChPoly c0) AERN2.Real.Type.CauchyReal => Numeric.MixedTypes.Field.CanDiv (AERN2.Frac.Type.Frac c0) AERN2.Real.Type.CauchyReal
instance (AERN2.Poly.Basics.PolyCoeffRing a, a ~ AERN2.MP.Ball.Type.MPBall) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Frac.Type.Frac a) (AERN2.Frac.Type.Frac a)
instance (AERN2.Poly.Basics.PolyCoeffRing a, a ~ AERN2.MP.Ball.Type.MPBall) => Numeric.MixedTypes.Ring.CanMulAsymmetric (AERN2.Poly.Cheb.Type.ChPoly a) (AERN2.Frac.Type.Frac a)
instance (AERN2.Poly.Basics.PolyCoeffRing a, a ~ AERN2.MP.Ball.Type.MPBall) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (AERN2.Frac.Type.Frac a) (AERN2.Frac.Type.Frac a)
instance Numeric.MixedTypes.Bool.CanNegSameType (AERN2.Poly.Cheb.Type.ChPoly a) => Numeric.MixedTypes.Bool.CanNeg (AERN2.Frac.Type.Frac a)

module AERN2.Frac.Field
inverseWithLowerBound :: (Field a) => (ChPoly a) -> a -> Frac a
instance Numeric.MixedTypes.Field.CanDiv (AERN2.Frac.Type.Frac AERN2.MP.Ball.Type.MPBall) (AERN2.Frac.Type.Frac AERN2.MP.Ball.Type.MPBall)
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer (AERN2.Frac.Type.Frac AERN2.MP.Ball.Type.MPBall)

module AERN2.Frac.Eval
evalDirect :: (Field t, CanAddSubMulDivBy t Dyadic, CanDivBy t Integer, CanAddSubMulBy t c, Ring c) => Frac c -> t -> t
evalDI :: Frac MPBall -> MPBall -> MPBall
evalDf :: Frac MPBall -> ChPoly MPBall -> ChPoly MPBall -> MPBall -> MPBall
evalLip :: Frac MPBall -> MPBall -> MPBall -> MPBall -> MPBall
instance (AERN2.RealFun.Operations.CanApply (AERN2.Poly.Cheb.Type.ChPoly c) t, Numeric.MixedTypes.Field.CanDivSameType (AERN2.RealFun.Operations.ApplyType (AERN2.Poly.Cheb.Type.ChPoly c) t)) => AERN2.RealFun.Operations.CanApply (AERN2.Frac.Type.Frac c) t
instance (AERN2.RealFun.Operations.CanApplyApprox (AERN2.Poly.Cheb.Type.ChPoly c) t, Numeric.MixedTypes.Field.CanDivSameType (AERN2.RealFun.Operations.ApplyApproxType (AERN2.Poly.Cheb.Type.ChPoly c) t)) => AERN2.RealFun.Operations.CanApplyApprox (AERN2.Frac.Type.Frac c) t

module AERN2.Frac.Maximum
maximumOptimisedWithAccuracy :: Accuracy -> Frac MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
maximumOptimised :: Frac MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
maximum :: Frac MPBall -> MPBall -> MPBall -> MPBall
minimum :: Frac MPBall -> MPBall -> MPBall -> MPBall
minimumOptimised :: Frac MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall
minimumOptimisedWithAccuracy :: Accuracy -> Frac MPBall -> MPBall -> MPBall -> Integer -> Integer -> MPBall

module AERN2.Frac.Conversion
toPPoly :: Frac MPBall -> PPoly

module AERN2.Frac.Integration
integral :: Frac MPBall -> MPBall -> MPBall -> MPBall
instance AERN2.RealFun.Operations.CanIntegrateOverDom (AERN2.Frac.Type.Frac AERN2.MP.Ball.Type.MPBall) AERN2.Interval.DyadicInterval

module AERN2.Frac

module AERN2.Local.Frac
type LocalFrac a = Local (Frac a)
fromPoly :: (ConvertibleExactly Integer a) => LocalPoly a -> LocalFrac a
instance AERN2.Local.Maximum.GenericMaximum (AERN2.Local.Frac.LocalFrac AERN2.MP.Ball.Type.MPBall)

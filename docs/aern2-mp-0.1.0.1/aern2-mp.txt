-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Multi-precision floats via haskell-mpfr or hmpfr
--   
--   A wrapper around MPFR (and, in future, an alternative to MPFR),
--   providing the types:
--   
--   <ul>
--   <li>Dyadic: variable-precision floats with exact ring operations</li>
--   <li>MPFloat: fixed-precision floats with approximate field &amp;
--   elementary operations</li>
--   <li>MPBall: float Â± error bound with field &amp; elementary
--   (interval-like) operations</li>
--   </ul>
--   
--   By default, we use hmpfr when compiling with ghc 7.10 and higher and
--   haskell-mpfr when compiling with ghc 7.8.
--   
--   There is also an Integer backend which does not need MPFR, but it is
--   not yet complete.
@package aern2-mp
@version 0.1.0.0


module AERN2.Utils.Bench
listFromGen :: Gen a -> [a]


module AERN2.Normalize
class CanNormalize t
normalize :: CanNormalize t => t -> t


module AERN2.Norm
class HasNorm a

-- | For a value <tt>x</tt>, return <tt>NormBits j</tt> where <tt>j</tt> is
--   close to the smallest <tt>i</tt> with <tt>|x| &lt;= 2^i</tt>. If <tt>x
--   == 0</tt> then return <tt>NormZero</tt>.
getNormLog :: HasNorm a => a -> NormLog
data NormLog

-- | ie NormBits (-infinity)
NormZero :: NormLog
NormBits :: Integer -> NormLog
invertNormLog :: NormLog -> NormLog
instance GHC.Show.Show AERN2.Norm.NormLog
instance GHC.Classes.Ord AERN2.Norm.NormLog
instance GHC.Classes.Eq AERN2.Norm.NormLog
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.Norm.NormLog AERN2.Norm.NormLog
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.Norm.NormLog AERN2.Norm.NormLog
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.Norm.NormLog AERN2.Norm.NormLog
instance AERN2.Norm.HasNorm GHC.Integer.Type.Integer
instance AERN2.Norm.HasNorm GHC.Types.Int
instance AERN2.Norm.HasNorm GHC.Real.Rational
instance AERN2.Norm.HasNorm t => AERN2.Norm.HasNorm (Data.Complex.Complex t)


-- | Floating-point precision type and its operations
module AERN2.MP.Precision
data Precision
prec :: Integer -> Precision
class HasPrecision t
getPrecision :: HasPrecision t => t -> Precision
class (HasPrecision t) => CanSetPrecision t
setPrecision :: CanSetPrecision t => Precision -> t -> t
lowerPrecisionIfAbove :: (CanSetPrecision t) => Precision -> t -> t
raisePrecisionIfBelow :: (CanSetPrecision t) => Precision -> t -> t
specCanSetPrecision :: (CanSetPrecision t, Arbitrary t, Show t, Testable prop) => (T t) -> (t -> t -> prop) -> Spec
defaultPrecision :: Precision
maximumPrecision :: Precision
standardPrecisions :: Precision -> [Precision]
precisionTimes2 :: Precision -> Precision
iterateUntilOK :: Precision -> (a -> Bool) -> (Precision -> a) -> [(Precision, a)]
class ConvertibleWithPrecision t1 t2
safeConvertP :: ConvertibleWithPrecision t1 t2 => Precision -> t1 -> ConvertResult t2
convertP :: (ConvertibleWithPrecision t1 t2) => Precision -> t1 -> t2
convertPFirst :: (ConvertibleWithPrecision t1 t2, HasPrecision t2) => (t2 -> t2 -> c) -> (t1 -> t2 -> c)
convertPSecond :: (ConvertibleWithPrecision t2 t1, HasPrecision t1) => (t1 -> t1 -> c) -> (t1 -> t2 -> c)
instance GHC.Real.Integral AERN2.MP.Precision.Precision
instance GHC.Real.Real AERN2.MP.Precision.Precision
instance GHC.Num.Num AERN2.MP.Precision.Precision
instance GHC.Enum.Enum AERN2.MP.Precision.Precision
instance GHC.Show.Show AERN2.MP.Precision.Precision
instance GHC.Classes.Ord AERN2.MP.Precision.Precision
instance GHC.Classes.Eq AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Precision.Precision AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Precision.Precision AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Precision.Precision AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Precision.Precision GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Precision.Precision GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Precision.Precision GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Precision.Precision GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Precision.Precision GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Precision.Precision AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Precision.Precision GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Precision.Precision AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Precision.Precision GHC.Integer.Type.Integer
instance AERN2.MP.Precision.HasPrecision t => AERN2.MP.Precision.HasPrecision (Data.Complex.Complex t)
instance AERN2.MP.Precision.CanSetPrecision t => AERN2.MP.Precision.CanSetPrecision (Data.Complex.Complex t)
instance AERN2.MP.Precision.HasPrecision t => AERN2.MP.Precision.HasPrecision (GHC.Base.Maybe t)
instance AERN2.MP.Precision.CanSetPrecision t => AERN2.MP.Precision.CanSetPrecision (GHC.Base.Maybe t)
instance AERN2.MP.Precision.HasPrecision GHC.Types.Bool
instance AERN2.MP.Precision.CanSetPrecision GHC.Types.Bool
instance AERN2.MP.Precision.HasPrecision t => AERN2.MP.Precision.HasPrecision (Control.CollectErrors.CollectErrors es t)
instance AERN2.MP.Precision.CanSetPrecision t => AERN2.MP.Precision.CanSetPrecision (Control.CollectErrors.CollectErrors es t)
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.MP.Precision.Precision


-- | Arbitrary precision floating-point numbers
--   
--   Currently, we use hmpfr when compiling with ghc 7.10 and higher and
--   haskell-mpfr when compiling with ghc 7.8.
module AERN2.MP.Float.Type

-- | Multiple-precision floating-point type based on MPFR via hmpfr.
type MPFloat = MPFR
setPrecisionUp :: Precision -> MPFloat -> MPFloat
setPrecisionDown :: Precision -> MPFloat -> MPFloat
p2mpfrPrec :: Precision -> Precision
instance AERN2.MP.Precision.HasPrecision AERN2.MP.Float.Type.MPFloat
instance AERN2.MP.Precision.CanSetPrecision AERN2.MP.Float.Type.MPFloat


-- | Arbitrary precision floating-point numbers with up/down-rounded
--   operations.
--   
--   Currently, we use hmpfr when compiling with ghc 7.10 and higher and
--   haskell-mpfr when compiling with ghc 7.8.
module AERN2.MP.Float.Arithmetic
addUp :: MPFloat -> MPFloat -> MPFloat
addDown :: MPFloat -> MPFloat -> MPFloat
subUp :: MPFloat -> MPFloat -> MPFloat
subDown :: MPFloat -> MPFloat -> MPFloat
mulUp :: MPFloat -> MPFloat -> MPFloat
mulDown :: MPFloat -> MPFloat -> MPFloat
divUp :: MPFloat -> MPFloat -> MPFloat
divDown :: MPFloat -> MPFloat -> MPFloat
recipUp :: MPFloat -> MPFloat
recipDown :: MPFloat -> MPFloat
piUp :: Precision -> MPFloat
piDown :: Precision -> MPFloat
cosUp :: MPFloat -> MPFloat
cosDown :: MPFloat -> MPFloat
sinUp :: MPFloat -> MPFloat
sinDown :: MPFloat -> MPFloat
sqrtUp :: MPFloat -> MPFloat
sqrtDown :: MPFloat -> MPFloat
expUp :: MPFloat -> MPFloat
expDown :: MPFloat -> MPFloat
logUp :: MPFloat -> MPFloat
logDown :: MPFloat -> MPFloat
instance Numeric.MixedTypes.Bool.CanNeg AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.MinMaxAbs.CanAbs AERN2.MP.Float.Type.MPFloat


-- | Conversions and comparisons of arbitrary precision floating point
--   numbers
--   
--   Currently, we use hmpfr when compiling with ghc 7.10 and higher and
--   haskell-mpfr when compiling with ghc 7.8.
module AERN2.MP.Float.Conversions
toDoubleUp :: MPFloat -> Double
toDoubleDown :: MPFloat -> Double
type CanBeMPFloat t = ConvertibleExactly t MPFloat
mpFloat :: (CanBeMPFloat t) => t -> MPFloat
fromIntegerUp :: Precision -> Integer -> MPFloat
fromIntegerDown :: Precision -> Integer -> MPFloat
fromRationalUp :: Precision -> Rational -> MPFloat
fromRationalDown :: Precision -> Rational -> MPFloat
instance AERN2.Norm.HasNorm AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Round.CanRound AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Float.Type.MPFloat GHC.Real.Rational
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int AERN2.MP.Float.Type.MPFloat
instance Data.Convertible.Base.Convertible AERN2.MP.Float.Type.MPFloat GHC.Types.Double
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Float.Type.MPFloat AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Float.Type.MPFloat GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Float.Type.MPFloat GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Float.Type.MPFloat GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Eq.CanTestZero AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Float.Type.MPFloat AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Float.Type.MPFloat GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Float.Type.MPFloat GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Float.Type.MPFloat GHC.Real.Rational
instance Numeric.MixedTypes.Ord.CanTestPosNeg AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Float.Type.MPFloat AERN2.MP.Float.Type.MPFloat


-- | Infix operators for up/down-rounded floating-point numbers
module AERN2.MP.Float.Operators
(+^) :: MPFloat -> MPFloat -> MPFloat
infixl 6 +^
(-^) :: MPFloat -> MPFloat -> MPFloat
infixl 6 -^
(*^) :: MPFloat -> MPFloat -> MPFloat
infixl 7 *^
(/^) :: MPFloat -> MPFloat -> MPFloat
infixl 7 /^
(+.) :: MPFloat -> MPFloat -> MPFloat
infixl 6 +.
(-.) :: MPFloat -> MPFloat -> MPFloat
infixl 6 -.
(*.) :: MPFloat -> MPFloat -> MPFloat
infixl 7 *.
(/.) :: MPFloat -> MPFloat -> MPFloat
infixl 7 /.


-- | Special constants NaN, infinity etc
module AERN2.MP.Float.Constants
zero :: MPFloat
one :: MPFloat
nan :: MPFloat
infinity :: MPFloat
instance Numeric.MixedTypes.Eq.CanTestFinite AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Eq.CanTestNaN AERN2.MP.Float.Type.MPFloat


-- | Tests for operations on arbitrary precision floats.
--   
--   To run the tests using stack, execute:
--   
--   <pre>
--   stack test aern2-mp --test-arguments "-a 1000 -m MPFloat"
--   
--   </pre>
module AERN2.MP.Float.Tests
specMPFloat :: Spec

-- | A runtime representative of type <tt>MPFloat</tt>. Used for
--   specialising polymorphic tests to concrete types.
tMPFloat :: T MPFloat
(=~=) :: MPFloat -> MPFloat -> Property
infix 4 =~=

-- | Assert equality of two MPFloat's with tolerance <tt>1/2^p</tt>.
approxEqual :: Integer -> MPFloat -> MPFloat -> Bool

-- | Assert equality of two MPFloat's with tolerance derived from the size
--   and precision of the given intermediate values. When the assertion
--   fails, report the given values using the given names.
approxEqualWithArgs :: [(MPFloat, String)] -> MPFloat -> MPFloat -> Property
frequencyElements :: ConvertibleExactly t Int => [(t, a)] -> Gen a
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.MP.Float.Type.MPFloat


-- | Arbitrary precision floating-point numbers with up/down-rounded
--   operations.
--   
--   Currently, we use hmpfr when compiling with ghc 7.10 and higher and
--   haskell-mpfr when compiling with ghc 7.8.
module AERN2.MP.Float

-- | Computes an upper bound to the distance <tt>|x - y|</tt> of <tt>x</tt>
--   and <tt>y</tt>.
distUp :: MPFloat -> MPFloat -> MPFloat

-- | Computes a lower bound to the distance <tt>|x - y|</tt> of <tt>x</tt>
--   and <tt>y</tt>.
distDown :: MPFloat -> MPFloat -> MPFloat
avgUp :: MPFloat -> MPFloat -> MPFloat
avgDown :: MPFloat -> MPFloat -> MPFloat


-- | A type for roughly measuring the accuracy of an enclosure.
module AERN2.MP.Accuracy

-- | A non-negative Double value to serve as an error bound. Arithmetic is
--   rounded towards +infinity.
data Accuracy
NoInformation :: Accuracy
Exact :: Accuracy
bits :: (ConvertibleExactly t Accuracy) => t -> Accuracy
fromAccuracy :: Accuracy -> Integer
class HasAccuracy a
getAccuracy :: HasAccuracy a => a -> Accuracy
class HasAccuracyGuide a
getAccuracyGuide :: HasAccuracyGuide a => a -> Accuracy
class HasAccuracyGuide a => CanSetAccuracyGuide a
setAccuracyGuide :: CanSetAccuracyGuide a => Accuracy -> a -> a
adjustAccuracyGuide :: (CanSetAccuracyGuide a) => (Accuracy -> Accuracy) -> a -> a

-- | Return accuracy, except when the element is Exact, return its nominal
--   Precision dressed as Accuracy. This function is useful when we have a
--   convergent sequence where all elements happen to be actually equal to
--   the limit and we need the property that the sequence elements keep
--   improving.
getFiniteAccuracy :: (HasAccuracy t, HasPrecision t) => t -> Accuracy
ac2prec :: Accuracy -> Precision
class CanReduceSizeUsingAccuracyGuide t
reduceSizeUsingAccuracyGuide :: CanReduceSizeUsingAccuracyGuide t => Accuracy -> t -> t
specCanReduceSizeUsingAccuracyGuide :: (CanReduceSizeUsingAccuracyGuide t, HasEqCertainly t t, Arbitrary t, Show t) => (T t) -> Spec
iterateUntilAccurate :: (HasAccuracy t) => Accuracy -> (Precision -> Maybe t) -> [(Precision, Maybe t)]
convergentList2CauchySeq :: (HasAccuracy t) => [t] -> (Accuracy -> t)
seqByPrecision2CauchySeq :: (HasAccuracy t) => (Precision -> t) -> (Accuracy -> t)

-- | Change the precision so that it is at least as high as the supplied
--   accuracy (assuming the accuracy is finite).
setPrecisionAtLeastAccuracy :: (CanSetPrecision t) => Accuracy -> t -> t

-- | An unsafe approximation of an enclosure or exact value, useful mainly
--   for showing something brief and readable to humans.
class HasApproximate t where type Approximate t where {
    type family Approximate t;
}
getApproximate :: HasApproximate t => Accuracy -> t -> (Approximate t)
instance GHC.Classes.Ord AERN2.MP.Accuracy.Accuracy
instance GHC.Classes.Eq AERN2.MP.Accuracy.Accuracy
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.MP.Accuracy.Accuracy
instance GHC.Enum.Enum AERN2.MP.Accuracy.Accuracy
instance GHC.Enum.Bounded AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Precision.Precision AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.Norm.NormLog AERN2.MP.Accuracy.Accuracy
instance GHC.Show.Show AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Accuracy.Accuracy AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Accuracy.Accuracy AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Accuracy.Accuracy AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Integer.Type.Integer
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Types.Int
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Bool.CanNeg AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Accuracy.Accuracy AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Accuracy.Accuracy AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Accuracy.Accuracy GHC.Integer.Type.Integer
instance (AERN2.MP.Accuracy.HasAccuracy a, Control.CollectErrors.SuitableForCE es) => AERN2.MP.Accuracy.HasAccuracy (Control.CollectErrors.CollectErrors es a)
instance AERN2.MP.Accuracy.HasAccuracy GHC.Types.Int
instance AERN2.MP.Accuracy.HasAccuracy GHC.Integer.Type.Integer
instance AERN2.MP.Accuracy.HasAccuracy GHC.Real.Rational
instance AERN2.MP.Accuracy.HasAccuracy GHC.Types.Bool
instance AERN2.MP.Accuracy.HasAccuracy t => AERN2.MP.Accuracy.HasAccuracy (Data.Complex.Complex t)
instance AERN2.MP.Accuracy.HasAccuracy t => AERN2.MP.Accuracy.HasAccuracy [t]
instance AERN2.MP.Accuracy.HasAccuracy t => AERN2.MP.Accuracy.HasAccuracy (GHC.Base.Maybe t)


-- | Arbitrary precision floating-point numbers with exact ring operations.
--   
--   Currently, we use hmpfr when compiling with ghc 7.10 and higher and
--   haskell-mpfr when compiling with ghc 7.8.
module AERN2.MP.Dyadic

-- | Exact dyadic type based on MPFloat.
data Dyadic
type HasDyadics t = ConvertibleExactly Dyadic t
type CanBeDyadic t = ConvertibleExactly t Dyadic
dyadic :: (CanBeDyadic t) => t -> Dyadic
specDyadic :: Spec

-- | A runtime representative of type <tt>Dyadic</tt>. Used for
--   specialising polymorphic tests to concrete types.
tDyadic :: T Dyadic
instance AERN2.Norm.HasNorm AERN2.MP.Dyadic.Dyadic
instance AERN2.MP.Precision.HasPrecision AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Round.CanRound AERN2.MP.Dyadic.Dyadic
instance GHC.Classes.Ord AERN2.MP.Dyadic.Dyadic
instance GHC.Classes.Eq AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.Ring AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.Ring (Numeric.CollectErrors.CN AERN2.MP.Dyadic.Dyadic)
instance Numeric.MixedTypes.Ring.OrderedRing AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.OrderedRing (Numeric.CollectErrors.CN AERN2.MP.Dyadic.Dyadic)
instance Numeric.MixedTypes.Ring.OrderedCertainlyRing AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.OrderedCertainlyRing (Numeric.CollectErrors.CN AERN2.MP.Dyadic.Dyadic)
instance AERN2.MP.Accuracy.HasAccuracy AERN2.MP.Dyadic.Dyadic
instance GHC.Show.Show AERN2.MP.Dyadic.Dyadic
instance GHC.Read.Read AERN2.MP.Dyadic.Dyadic
instance Control.CollectErrors.SuitableForCE es => Control.CollectErrors.CanEnsureCE es AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Dyadic.Dyadic AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Float.Type.MPFloat AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Round.HasIntegerBounds AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Data.Convertible.Base.Convertible AERN2.MP.Dyadic.Dyadic GHC.Types.Double
instance (Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Dyadic.Dyadic t, GHC.Base.Monoid es) => Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Dyadic.Dyadic (Control.CollectErrors.CollectErrors es t)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Dyadic.Dyadic b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Eq.EqCompareType AERN2.MP.Dyadic.Dyadic b), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es (Numeric.MixedTypes.Eq.EqCompareType AERN2.MP.Dyadic.Dyadic b)), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Dyadic.Dyadic (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric a AERN2.MP.Dyadic.Dyadic, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Eq.EqCompareType a AERN2.MP.Dyadic.Dyadic), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es (Numeric.MixedTypes.Eq.EqCompareType a AERN2.MP.Dyadic.Dyadic)), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Eq.HasEqAsymmetric (Control.CollectErrors.CollectErrors es a) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Eq.CanTestZero AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Dyadic.Dyadic b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ord.OrderCompareType AERN2.MP.Dyadic.Dyadic b), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es (Numeric.MixedTypes.Ord.OrderCompareType AERN2.MP.Dyadic.Dyadic b)), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Dyadic.Dyadic (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric a AERN2.MP.Dyadic.Dyadic, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ord.OrderCompareType a AERN2.MP.Dyadic.Dyadic), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es (Numeric.MixedTypes.Ord.OrderCompareType a AERN2.MP.Dyadic.Dyadic)), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ord.HasOrderAsymmetric (Control.CollectErrors.CollectErrors es a) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ord.CanTestPosNeg AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Eq.CanTestInteger AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Bool.CanNeg AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.MinMaxAbs.CanAbs AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.MinMaxAbs.MinMaxType AERN2.MP.Dyadic.Dyadic b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric a AERN2.MP.Dyadic.Dyadic, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.MinMaxAbs.MinMaxType a AERN2.MP.Dyadic.Dyadic), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (Control.CollectErrors.CollectErrors es a) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.AddSub.AddType AERN2.MP.Dyadic.Dyadic b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric a AERN2.MP.Dyadic.Dyadic, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.AddSub.AddType a AERN2.MP.Dyadic.Dyadic), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (Control.CollectErrors.CollectErrors es a) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance (Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.AddSub.SubType AERN2.MP.Dyadic.Dyadic b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.AddSub.CanSub a AERN2.MP.Dyadic.Dyadic, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.AddSub.SubType a AERN2.MP.Dyadic.Dyadic), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.AddSub.CanSub (Control.CollectErrors.CollectErrors es a) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.MulType AERN2.MP.Dyadic.Dyadic b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric a AERN2.MP.Dyadic.Dyadic, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.MulType a AERN2.MP.Dyadic.Dyadic), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ring.CanMulAsymmetric (Control.CollectErrors.CollectErrors es a) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance (Numeric.MixedTypes.Field.CanDiv a AERN2.MP.Dyadic.Dyadic, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Field.DivType a AERN2.MP.Dyadic.Dyadic), Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Field.DivTypeNoCN a AERN2.MP.Dyadic.Dyadic), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Field.CanDiv (Control.CollectErrors.CollectErrors es a) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance (Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Field.DivType AERN2.MP.Dyadic.Dyadic b), Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Field.DivTypeNoCN AERN2.MP.Dyadic.Dyadic b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.Ring.CanPow AERN2.MP.Dyadic.Dyadic b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.PowTypeNoCN AERN2.MP.Dyadic.Dyadic b), Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.PowType AERN2.MP.Dyadic.Dyadic b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ring.CanPow AERN2.MP.Dyadic.Dyadic (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.Ring.CanPow a AERN2.MP.Dyadic.Dyadic, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.PowType a AERN2.MP.Dyadic.Dyadic), Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.PowTypeNoCN a AERN2.MP.Dyadic.Dyadic), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ring.CanPow (Control.CollectErrors.CollectErrors es a) AERN2.MP.Dyadic.Dyadic
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.MP.Dyadic.Dyadic
instance GHC.Num.Num AERN2.MP.Dyadic.Dyadic
instance GHC.Real.Real AERN2.MP.Dyadic.Dyadic


-- | Fixed precision non-negative up-rounded floating-point numbers.
--   
--   Currently using a fixed-precision MPFloat.
module AERN2.MP.ErrorBound

-- | A non-negative Double value to serve as an error bound. Arithmetic is
--   rounded towards +infinity.
data ErrorBound
type CanBeErrorBound t = Convertible t ErrorBound
errorBound :: (CanBeErrorBound t) => t -> ErrorBound
absMP :: MPFloat -> ErrorBound
subMP :: MPFloat -> MPFloat -> ErrorBound
instance GHC.Classes.Ord AERN2.MP.ErrorBound.ErrorBound
instance GHC.Classes.Eq AERN2.MP.ErrorBound.ErrorBound
instance GHC.Show.Show AERN2.MP.ErrorBound.ErrorBound
instance AERN2.MP.Accuracy.HasAccuracy AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.ErrorBound.ErrorBound AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.ErrorBound.ErrorBound AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.ErrorBound.ErrorBound GHC.Real.Rational
instance Data.Convertible.Base.Convertible GHC.Real.Rational AERN2.MP.ErrorBound.ErrorBound
instance Data.Convertible.Base.Convertible AERN2.MP.Float.Type.MPFloat AERN2.MP.ErrorBound.ErrorBound
instance Data.Convertible.Base.Convertible GHC.Integer.Type.Integer AERN2.MP.ErrorBound.ErrorBound
instance Data.Convertible.Base.Convertible GHC.Types.Int AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.ErrorBound.ErrorBound AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.ErrorBound.ErrorBound AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Float.Type.MPFloat AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Real.Rational
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.ErrorBound.ErrorBound AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.ErrorBound.ErrorBound AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.ErrorBound.ErrorBound AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Float.Type.MPFloat AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.ErrorBound.ErrorBound AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.ErrorBound.ErrorBound AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Float.Type.MPFloat AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.ErrorBound.ErrorBound GHC.Integer.Type.Integer
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.MP.ErrorBound.ErrorBound


-- | Enclosure classes and operations.
module AERN2.MP.Enclosure
class IsBall t where type CentreType t centreAsBall = fst . centreAsBallAndRadius radius = snd . centreAsBallAndRadius makeExactCentre v = updateRadius (+ r) c where (c, r) = centreAsBallAndRadius v where {
    type family CentreType t;
}
centre :: IsBall t => t -> CentreType t
centreAsBallAndRadius :: IsBall t => t -> (t, ErrorBound)
centreAsBall :: IsBall t => t -> t
radius :: IsBall t => t -> ErrorBound
updateRadius :: IsBall t => (ErrorBound -> ErrorBound) -> (t -> t)

-- | When the radius of the ball is implicitly contributed to by
--   imprecision in the centre (eg if the centre is a polynomial with
--   inexact coefficients), move all that imprecision to the explicit
--   radius, making the centre exact. This may lose some information, but
--   as a ball is equivalent to the original. For MPBall this function is
--   pointless because it is equivalent to the identity.
makeExactCentre :: (IsBall t, IsBall t) => t -> t
class IsInterval i e
fromEndpoints :: IsInterval i e => e -> e -> i
endpoints :: IsInterval i e => i -> (e, e)

-- | Computes a *monotone* ball function <tt>f</tt> on intervals using the
--   interval endpoints.
intervalFunctionByEndpoints :: (IsInterval t t, HasEqCertainly t t) => (t -> t) -> (t -> t)

-- | Computes a *monotone* ball function <tt>f</tt> on intervals using the
--   interval endpoints.
intervalFunctionByEndpointsUpDown :: (IsInterval t e) => (e -> e) -> (e -> e) -> (t -> t)
class CanTestContains dom e

-- | Test if <tt>e</tt> is inside <tt>dom</tt>.
contains :: CanTestContains dom e => dom -> e -> Bool
class CanMapInside dom e

-- | Return some value contained in <tt>dom</tt>. The returned value does
--   not have to equal the given <tt>e</tt> even if <tt>e</tt> is already
--   inside <tt>dom</tt>. All elements of <tt>dom</tt> should be covered
--   with roughly the same probability when calling this function for
--   evenly distributed <tt>e</tt>'s.
--   
--   This function is intended mainly for generating values inside
--   <tt>dom</tt> for randomised tests.
mapInside :: CanMapInside dom e => dom -> e -> e
specCanMapInside :: (CanMapInside d e, CanTestContains d e, Arbitrary d, Arbitrary e, Show d, Show e) => T d -> T e -> Spec
class CanIntersectAsymmetric e1 e2 where type IntersectionType e1 e2 type IntersectionType e1 e2 = EnsureCN e1 where {
    type family IntersectionType e1 e2;
    type IntersectionType e1 e2 = EnsureCN e1;
}
intersect :: CanIntersectAsymmetric e1 e2 => e1 -> e2 -> IntersectionType e1 e2
type CanIntersect e1 e2 = (CanIntersectAsymmetric e1 e2, CanIntersectAsymmetric e1 e2, IntersectionType e1 e2 ~ IntersectionType e2 e1)
type CanIntersectCNBy e1 e2 = (CanIntersect e1 e2, IntersectionType e1 e2 ~ EnsureCN e1, CanIntersect (EnsureCN e1) e2, IntersectionType (EnsureCN e1) e2 ~ EnsureCN e1)
type CanIntersectCNSameType e1 = (CanIntersectCNBy e1 e1, CanIntersect (EnsureCN e1) (EnsureCN e1), IntersectionType (EnsureCN e1) (EnsureCN e1) ~ EnsureCN e1)
class CanUnionAsymmetric e1 e2 where type UnionType e1 e2 type UnionType e1 e2 = EnsureCN e1 where {
    type family UnionType e1 e2;
    type UnionType e1 e2 = EnsureCN e1;
}
union :: CanUnionAsymmetric e1 e2 => e1 -> e2 -> UnionType e1 e2
type CanUnion e1 e2 = (CanUnionAsymmetric e1 e2, CanUnionAsymmetric e1 e2, UnionType e1 e2 ~ UnionType e2 e1)
type CanUnionCNBy e1 e2 = (CanUnion e1 e2, UnionType e1 e2 ~ EnsureCN e1, CanUnion (EnsureCN e1) e2, UnionType (EnsureCN e1) e2 ~ EnsureCN e1)
type CanUnionCNSameType e1 = (CanUnionCNBy e1 e1, CanUnion (EnsureCN e1) (EnsureCN e1), UnionType (EnsureCN e1) (EnsureCN e1) ~ EnsureCN e1)
instance AERN2.MP.Enclosure.CanIntersectAsymmetric GHC.Types.Bool GHC.Types.Bool
instance (AERN2.MP.Enclosure.CanIntersectAsymmetric GHC.Types.Bool b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (AERN2.MP.Enclosure.IntersectionType GHC.Types.Bool b), Control.CollectErrors.SuitableForCE es) => AERN2.MP.Enclosure.CanIntersectAsymmetric GHC.Types.Bool (Control.CollectErrors.CollectErrors es b)
instance (AERN2.MP.Enclosure.CanIntersectAsymmetric a GHC.Types.Bool, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (AERN2.MP.Enclosure.IntersectionType a GHC.Types.Bool), Control.CollectErrors.SuitableForCE es) => AERN2.MP.Enclosure.CanIntersectAsymmetric (Control.CollectErrors.CollectErrors es a) GHC.Types.Bool
instance (AERN2.MP.Enclosure.CanIntersectAsymmetric (GHC.Base.Maybe a) b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (AERN2.MP.Enclosure.IntersectionType (GHC.Base.Maybe a) b), Control.CollectErrors.SuitableForCE es) => AERN2.MP.Enclosure.CanIntersectAsymmetric (GHC.Base.Maybe a) (Control.CollectErrors.CollectErrors es b)
instance (AERN2.MP.Enclosure.CanIntersectAsymmetric a (GHC.Base.Maybe b), Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (AERN2.MP.Enclosure.IntersectionType a (GHC.Base.Maybe b)), Control.CollectErrors.SuitableForCE es) => AERN2.MP.Enclosure.CanIntersectAsymmetric (Control.CollectErrors.CollectErrors es a) (GHC.Base.Maybe b)
instance (AERN2.MP.Enclosure.CanIntersectAsymmetric a b, Numeric.CollectErrors.CanEnsureCN a, AERN2.MP.Enclosure.IntersectionType a b ~ Numeric.CollectErrors.EnsureCN a, Numeric.CollectErrors.CanEnsureCN (Numeric.CollectErrors.EnsureCN a), Numeric.CollectErrors.CanEnsureCN b, Numeric.CollectErrors.EnsureCN b ~ Numeric.CollectErrors.EnsureCN a) => AERN2.MP.Enclosure.CanIntersectAsymmetric (GHC.Base.Maybe a) (GHC.Base.Maybe b)
instance (AERN2.MP.Enclosure.CanIntersectAsymmetric e1 e2, Control.CollectErrors.SuitableForCE es, Control.CollectErrors.CanEnsureCE es e1, Control.CollectErrors.CanEnsureCE es e2, Control.CollectErrors.CanEnsureCE es (AERN2.MP.Enclosure.IntersectionType e1 e2)) => AERN2.MP.Enclosure.CanIntersectAsymmetric (Control.CollectErrors.CollectErrors es e1) (Control.CollectErrors.CollectErrors es e2)
instance (AERN2.MP.Enclosure.CanUnionAsymmetric e1 e2, Numeric.CollectErrors.CanEnsureCN e1, Numeric.CollectErrors.CanEnsureCN e2, Numeric.CollectErrors.CanEnsureCN (AERN2.MP.Enclosure.UnionType e1 e2)) => AERN2.MP.Enclosure.CanUnionAsymmetric (Numeric.CollectErrors.CN e1) (Numeric.CollectErrors.CN e2)
instance (Control.Arrow.Arrow to, AERN2.MP.Enclosure.CanUnionAsymmetric e1 e2) => AERN2.MP.Enclosure.CanUnionAsymmetric (to AERN2.MP.Accuracy.Accuracy e1) (to AERN2.MP.Accuracy.Accuracy e2)
instance (AERN2.MP.Enclosure.CanUnionCNSameType t, Numeric.CollectErrors.CanEnsureCN t) => Numeric.MixedTypes.Literals.HasIfThenElse (GHC.Base.Maybe GHC.Types.Bool) t


-- | Arbitrary precision dyadic balls
module AERN2.MP.Ball.Type
data MPBall
MPBall :: MPFloat -> ErrorBound -> MPBall
[ball_value] :: MPBall -> MPFloat
[ball_error] :: MPBall -> ErrorBound
type CanBeMPBall t = ConvertibleExactly t MPBall
mpBall :: (CanBeMPBall t) => t -> MPBall
type CanBeMPBallP t = ConvertibleWithPrecision t MPBall
mpBallP :: (CanBeMPBallP t) => Precision -> t -> MPBall

-- | Reduce the precision of the ball centre if the accuracy of the ball is
--   poor.
--   
--   More precisely, reduce the precision of the centre so that the ulp is
--   approximately (radius / 1024), unless the ulp is already lower than
--   this.
reducePrecionIfInaccurate :: MPBall -> MPBall
endpointsMP :: MPBall -> (MPFloat, MPFloat)
fromEndpointsMP :: MPFloat -> MPFloat -> MPBall
instance AERN2.MP.Enclosure.CanTestContains AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance AERN2.MP.Enclosure.CanTestContains AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance AERN2.MP.Enclosure.CanTestContains AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance AERN2.MP.Enclosure.CanTestContains AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance AERN2.MP.Enclosure.IsInterval AERN2.MP.Ball.Type.MPBall AERN2.MP.Float.Type.MPFloat
instance AERN2.MP.Enclosure.IsInterval AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Enclosure.IsBall AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Accuracy.HasAccuracy AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Accuracy.CanReduceSizeUsingAccuracyGuide AERN2.MP.Ball.Type.MPBall
instance AERN2.Norm.HasNorm AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Accuracy.HasApproximate AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Precision.HasPrecision AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Precision.CanSetPrecision AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Bool.CanNeg AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.MinMaxAbs.CanAbs AERN2.MP.Ball.Type.MPBall
instance GHC.Generics.Generic AERN2.MP.Ball.Type.MPBall
instance GHC.Show.Show AERN2.MP.Ball.Type.MPBall
instance Control.CollectErrors.SuitableForCE es => Control.CollectErrors.CanEnsureCE es AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.CanTestNaN AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.CanTestFinite AERN2.MP.Ball.Type.MPBall
instance AERN2.Normalize.CanNormalize AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Enclosure.CanTestContains AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall


-- | Conversions of arbitrary precision dyadic balls
module AERN2.MP.Ball.Conversions
integerBounds :: HasIntegerBounds t => t -> (Integer, Integer)
instance Numeric.MixedTypes.Round.HasIntegerBounds AERN2.MP.Ball.Type.MPBall
instance Data.Convertible.Base.Convertible AERN2.MP.Ball.Type.MPBall AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.ErrorBound.ErrorBound AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.Literals.ConvertibleExactly c AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Literals.ConvertibleExactly e AERN2.MP.Dyadic.Dyadic, GHC.Show.Show c, GHC.Show.Show e, Data.Typeable.Internal.Typeable c, Data.Typeable.Internal.Typeable e) => Numeric.MixedTypes.Literals.ConvertibleExactly (c, e) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Precision.ConvertibleWithPrecision GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Precision.ConvertibleWithPrecision GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Precision.ConvertibleWithPrecision AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Precision.ConvertibleWithPrecision GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Precision.ConvertibleWithPrecision (GHC.Real.Rational, GHC.Real.Rational) AERN2.MP.Ball.Type.MPBall


-- | Comparisons of arbitrary precision dyadic balls
module AERN2.MP.Ball.Comparisons

-- | Reduce the precision of the ball centre if the accuracy of the ball is
--   poor.
--   
--   More precisely, reduce the precision of the centre so that the ulp is
--   approximately (radius / 1024), unless the ulp is already lower than
--   this.
reducePrecionIfInaccurate :: MPBall -> MPBall

-- | Computes an *increasing* ball fucntion <tt>f</tt> from *exact* MPFR
--   operations.
byEndpointsMP :: (MPFloat -> MPFloat -> MPFloat) -> (MPBall -> MPBall -> MPBall)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Ball.Type.MPBall b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Eq.EqCompareType AERN2.MP.Ball.Type.MPBall b), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es (Numeric.MixedTypes.Eq.EqCompareType AERN2.MP.Ball.Type.MPBall b)), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Ball.Type.MPBall (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.Eq.HasEqAsymmetric a AERN2.MP.Ball.Type.MPBall, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Eq.EqCompareType a AERN2.MP.Ball.Type.MPBall), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es (Numeric.MixedTypes.Eq.EqCompareType a AERN2.MP.Ball.Type.MPBall)), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Eq.HasEqAsymmetric (Control.CollectErrors.CollectErrors es a) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Ball.Type.MPBall b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ord.OrderCompareType AERN2.MP.Ball.Type.MPBall b), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es (Numeric.MixedTypes.Ord.OrderCompareType AERN2.MP.Ball.Type.MPBall b)), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Ball.Type.MPBall (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.Ord.HasOrderAsymmetric a AERN2.MP.Ball.Type.MPBall, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ord.OrderCompareType a AERN2.MP.Ball.Type.MPBall), Numeric.MixedTypes.Bool.IsBool (Control.CollectErrors.EnsureCE es (Numeric.MixedTypes.Ord.OrderCompareType a AERN2.MP.Ball.Type.MPBall)), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ord.HasOrderAsymmetric (Control.CollectErrors.CollectErrors es a) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.CanTestZero AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ord.CanTestPosNeg AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.CanTestInteger AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Ball.Type.MPBall b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.MinMaxAbs.MinMaxType AERN2.MP.Ball.Type.MPBall b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Ball.Type.MPBall (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric a AERN2.MP.Ball.Type.MPBall, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.MinMaxAbs.MinMaxType a AERN2.MP.Ball.Type.MPBall), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (Control.CollectErrors.CollectErrors es a) AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Enclosure.CanIntersectAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance (AERN2.MP.Enclosure.CanIntersectAsymmetric AERN2.MP.Ball.Type.MPBall b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (AERN2.MP.Enclosure.IntersectionType AERN2.MP.Ball.Type.MPBall b), Control.CollectErrors.SuitableForCE es) => AERN2.MP.Enclosure.CanIntersectAsymmetric AERN2.MP.Ball.Type.MPBall (Control.CollectErrors.CollectErrors es b)
instance (AERN2.MP.Enclosure.CanIntersectAsymmetric a AERN2.MP.Ball.Type.MPBall, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (AERN2.MP.Enclosure.IntersectionType a AERN2.MP.Ball.Type.MPBall), Control.CollectErrors.SuitableForCE es) => AERN2.MP.Enclosure.CanIntersectAsymmetric (Control.CollectErrors.CollectErrors es a) AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Enclosure.CanUnionAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance (AERN2.MP.Enclosure.CanUnionAsymmetric AERN2.MP.Ball.Type.MPBall b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (AERN2.MP.Enclosure.UnionType AERN2.MP.Ball.Type.MPBall b), Control.CollectErrors.SuitableForCE es) => AERN2.MP.Enclosure.CanUnionAsymmetric AERN2.MP.Ball.Type.MPBall (Control.CollectErrors.CollectErrors es b)
instance (AERN2.MP.Enclosure.CanUnionAsymmetric a AERN2.MP.Ball.Type.MPBall, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (AERN2.MP.Enclosure.UnionType a AERN2.MP.Ball.Type.MPBall), Control.CollectErrors.SuitableForCE es) => AERN2.MP.Enclosure.CanUnionAsymmetric (Control.CollectErrors.CollectErrors es a) AERN2.MP.Ball.Type.MPBall


-- | Field operations on arbitrary precision dyadic balls
module AERN2.MP.Ball.Field
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Field.DivType AERN2.MP.Ball.Type.MPBall b), Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Field.DivTypeNoCN AERN2.MP.Ball.Type.MPBall b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.Field.CanDiv a AERN2.MP.Ball.Type.MPBall, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Field.DivType a AERN2.MP.Ball.Type.MPBall), Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Field.DivTypeNoCN a AERN2.MP.Ball.Type.MPBall), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Field.CanDiv (Control.CollectErrors.CollectErrors es a) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance (Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.PowType AERN2.MP.Ball.Type.MPBall b), Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.PowTypeNoCN AERN2.MP.Ball.Type.MPBall b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.Ring.CanPow a AERN2.MP.Ball.Type.MPBall, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.PowType a AERN2.MP.Ball.Type.MPBall), Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.PowTypeNoCN a AERN2.MP.Ball.Type.MPBall), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ring.CanPow (Control.CollectErrors.CollectErrors es a) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.AddSub.AddType AERN2.MP.Ball.Type.MPBall b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric a AERN2.MP.Ball.Type.MPBall, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.AddSub.AddType a AERN2.MP.Ball.Type.MPBall), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (Control.CollectErrors.CollectErrors es a) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.AddSub.SubType AERN2.MP.Ball.Type.MPBall b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.AddSub.CanSub a AERN2.MP.Ball.Type.MPBall, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.AddSub.SubType a AERN2.MP.Ball.Type.MPBall), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.AddSub.CanSub (Control.CollectErrors.CollectErrors es a) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall b, Control.CollectErrors.CanEnsureCE es b, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.MulType AERN2.MP.Ball.Type.MPBall b), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall (Control.CollectErrors.CollectErrors es b)
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric a AERN2.MP.Ball.Type.MPBall, Control.CollectErrors.CanEnsureCE es a, Control.CollectErrors.CanEnsureCE es (Numeric.MixedTypes.Ring.MulType a AERN2.MP.Ball.Type.MPBall), Control.CollectErrors.SuitableForCE es) => Numeric.MixedTypes.Ring.CanMulAsymmetric (Control.CollectErrors.CollectErrors es a) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall


-- | Elementary operations on arbitrary precision dyadic balls
module AERN2.MP.Ball.Elementary
piBallP :: Precision -> MPBall

-- | Computes a real function <tt>f</tt> from correctly rounded
--   MPFR-approximations and a number <tt>lip</tt> which is a Lipschitz
--   constant for <tt>f</tt>, i.e. <tt>|f(x) - f(y)| &lt;= lip * |x -
--   y|</tt> for all <tt>x</tt>,<tt>y</tt>.
fromApproxWithLipschitz :: (MPFloat -> MPFloat) -> (MPFloat -> MPFloat) -> MPFloat -> (MPBall -> MPBall)
instance Numeric.MixedTypes.Elementary.CanSinCos AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Elementary.CanExp AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Elementary.CanLog AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.Elementary.CanSqrt AERN2.MP.Ball.Type.MPBall


-- | Instances of Prelude classes Eq, Ord, Num etc
module AERN2.MP.Ball.PreludeOps
instance GHC.Classes.Eq AERN2.MP.Ball.Type.MPBall
instance GHC.Classes.Ord AERN2.MP.Ball.Type.MPBall
instance GHC.Num.Num AERN2.MP.Ball.Type.MPBall
instance GHC.Real.Fractional AERN2.MP.Ball.Type.MPBall
instance GHC.Float.Floating AERN2.MP.Ball.Type.MPBall


-- | Arbitrary precision ball arithmetic
module AERN2.MP.Ball
data MPBall
MPBall :: MPFloat -> ErrorBound -> MPBall
[ball_value] :: MPBall -> MPFloat
[ball_error] :: MPBall -> ErrorBound
type CanBeMPBall t = ConvertibleExactly t MPBall
mpBall :: (CanBeMPBall t) => t -> MPBall
type CanBeMPBallP t = ConvertibleWithPrecision t MPBall
mpBallP :: (CanBeMPBallP t) => Precision -> t -> MPBall

-- | Reduce the precision of the ball centre if the accuracy of the ball is
--   poor.
--   
--   More precisely, reduce the precision of the centre so that the ulp is
--   approximately (radius / 1024), unless the ulp is already lower than
--   this.
reducePrecionIfInaccurate :: MPBall -> MPBall
piBallP :: Precision -> MPBall

-- | Computes an *increasing* ball fucntion <tt>f</tt> from *exact* MPFR
--   operations.
byEndpointsMP :: (MPFloat -> MPFloat -> MPFloat) -> (MPBall -> MPBall -> MPBall)

-- | Computes a real function <tt>f</tt> from correctly rounded
--   MPFR-approximations and a number <tt>lip</tt> which is a Lipschitz
--   constant for <tt>f</tt>, i.e. <tt>|f(x) - f(y)| &lt;= lip * |x -
--   y|</tt> for all <tt>x</tt>,<tt>y</tt>.
fromApproxWithLipschitz :: (MPFloat -> MPFloat) -> (MPFloat -> MPFloat) -> MPFloat -> (MPBall -> MPBall)
instance Numeric.MixedTypes.Ring.Ring AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.Ring (Numeric.CollectErrors.CN AERN2.MP.Ball.Type.MPBall)
instance Numeric.MixedTypes.Field.Field AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.Field (Numeric.CollectErrors.CN AERN2.MP.Ball.Type.MPBall)
instance Numeric.MixedTypes.Ring.OrderedRing AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.OrderedRing (Numeric.CollectErrors.CN AERN2.MP.Ball.Type.MPBall)
instance Numeric.MixedTypes.Field.OrderedField AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.OrderedField (Numeric.CollectErrors.CN AERN2.MP.Ball.Type.MPBall)
instance Numeric.MixedTypes.Ring.OrderedCertainlyRing AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.OrderedCertainlyRing (Numeric.CollectErrors.CN AERN2.MP.Ball.Type.MPBall)
instance Numeric.MixedTypes.Field.OrderedCertainlyField AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.OrderedCertainlyField (Numeric.CollectErrors.CN AERN2.MP.Ball.Type.MPBall)


-- | Tests for operations on arbitrary precision balls.
--   
--   To run the tests using stack, execute:
--   
--   <pre>
--   stack test aern2-mp --test-arguments "-a 1000 -m MPBall"
--   
--   </pre>
module AERN2.MP.Ball.Tests
specMPBall :: Spec

-- | A runtime representative of type <tt>MPBall</tt>. Used for
--   specialising polymorphic tests to concrete types.
tMPBall :: T MPBall
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.MP.Ball.Type.MPBall


-- | Multiple-precision ball arithmetic
module AERN2.MP
data MPBall
MPBall :: MPFloat -> ErrorBound -> MPBall
[ball_value] :: MPBall -> MPFloat
[ball_error] :: MPBall -> ErrorBound
type CanBeMPBall t = ConvertibleExactly t MPBall
mpBall :: (CanBeMPBall t) => t -> MPBall
type CanBeMPBallP t = ConvertibleWithPrecision t MPBall
mpBallP :: (CanBeMPBallP t) => Precision -> t -> MPBall

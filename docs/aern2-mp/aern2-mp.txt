-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Multi-precision floats via haskell-mpfr or hmpfr
--   
--   A wrapper around MPFR (and, in future, an alternative to MPFR),
--   providing the types:
--   
--   <ul>
--   <li>Dyadic: variable-precision floats with exact ring operations</li>
--   <li>MPFloat: fixed-precision floats with approximate field &amp;
--   elementary operations</li>
--   <li>MPBall: float Â± error bound with field &amp; elementary
--   (interval-like) operations</li>
--   </ul>
--   
--   By default, we use hmpfr when compiling with ghc 7.10 and higher and
--   haskell-mpfr when compiling with ghc 7.8.
--   
--   There is also an Integer backend which does not need MPFR, but it is
--   not yet complete.
@package aern2-mp
@version 0.1.0.0


-- | Template Haskell utilities
module AERN2.Utils.TH

-- | A toy example of use:
--   
--   <pre>
--   class HasTT t where
--     type TT t
--     getTT :: t -&gt; TT t
--   
--   $(declForTypes
--     [[t| Integer |], [t| Int |], [t| Rational |]]
--     ( t -&gt; [d|
--       instance HasTT $t where
--         type TT $t = ()
--         getTT _ = ()
--     |]))
--   </pre>
declForTypes :: [Q Type] -> (Q Type -> Q [Dec]) -> Q [Dec]


module AERN2.Utils.Bench
listFromGen :: Gen a -> [a]


module AERN2.Normalize
class CanNormalize t
normalize :: CanNormalize t => t -> t


module AERN2.Norm
class HasNorm a

-- | For a value <tt>x</tt>, return <tt>NormBits j</tt> where <tt>j</tt> is
--   close to the smallest <tt>i</tt> with <tt>|x| &lt;= 2^i</tt>. If <tt>x
--   == 0</tt> then return <tt>NormZero</tt>.
getNormLog :: HasNorm a => a -> NormLog
data NormLog

-- | ie NormBits (-infinity)
NormZero :: NormLog
NormBits :: Integer -> NormLog
invertNormLog :: NormLog -> NormLog
instance GHC.Show.Show AERN2.Norm.NormLog
instance GHC.Classes.Ord AERN2.Norm.NormLog
instance GHC.Classes.Eq AERN2.Norm.NormLog
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.Norm.NormLog AERN2.Norm.NormLog
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.Norm.NormLog AERN2.Norm.NormLog
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.Norm.NormLog AERN2.Norm.NormLog
instance AERN2.Norm.HasNorm GHC.Integer.Type.Integer
instance AERN2.Norm.HasNorm GHC.Types.Int
instance AERN2.Norm.HasNorm GHC.Real.Rational
instance AERN2.Norm.HasNorm t => AERN2.Norm.HasNorm (Data.Complex.Complex t)


-- | Floating-point precision type and its operations
module AERN2.MP.Precision
data Precision
prec :: Integer -> Precision
class HasPrecision t
getPrecision :: HasPrecision t => t -> Precision
class (HasPrecision t) => CanSetPrecision t
setPrecision :: CanSetPrecision t => Precision -> t -> t
lowerPrecisionIfAbove :: (CanSetPrecision t) => Precision -> t -> t
raisePrecisionIfBelow :: (CanSetPrecision t) => Precision -> t -> t
specCanSetPrecision :: (CanSetPrecision t, Arbitrary t, Show t, Testable prop) => (T t) -> (t -> t -> prop) -> Spec
defaultPrecision :: Precision
maximumPrecision :: Precision
standardPrecisions :: [Precision]
precisionTimes2 :: Precision -> Precision
iterateUntilOK :: (a -> Bool) -> (Precision -> a) -> [(Precision, a)]
class ConvertibleWithPrecision t1 t2
safeConvertP :: ConvertibleWithPrecision t1 t2 => Precision -> t1 -> ConvertResult t2
convertP :: (ConvertibleWithPrecision t1 t2) => Precision -> t1 -> t2
convertPFirst :: (ConvertibleWithPrecision t1 t2, HasPrecision t2) => (t2 -> t2 -> c) -> (t1 -> t2 -> c)
convertPSecond :: (ConvertibleWithPrecision t2 t1, HasPrecision t1) => (t1 -> t1 -> c) -> (t1 -> t2 -> c)
instance GHC.Real.Integral AERN2.MP.Precision.Precision
instance GHC.Real.Real AERN2.MP.Precision.Precision
instance GHC.Num.Num AERN2.MP.Precision.Precision
instance GHC.Enum.Enum AERN2.MP.Precision.Precision
instance GHC.Show.Show AERN2.MP.Precision.Precision
instance GHC.Classes.Ord AERN2.MP.Precision.Precision
instance GHC.Classes.Eq AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Precision.Precision AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Precision.Precision AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Precision.Precision AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Precision.Precision GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Precision.Precision GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Precision.Precision GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Precision.Precision GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Precision.Precision GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Precision.Precision AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Precision.Precision GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Precision.Precision AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer AERN2.MP.Precision.Precision
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Precision.Precision GHC.Integer.Type.Integer
instance AERN2.MP.Precision.HasPrecision t => AERN2.MP.Precision.HasPrecision (Data.Complex.Complex t)
instance AERN2.MP.Precision.CanSetPrecision t => AERN2.MP.Precision.CanSetPrecision (Data.Complex.Complex t)
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.MP.Precision.Precision


-- | Arbitrary precision floating-point numbers
--   
--   Currently, we use hmpfr when compiling with ghc 7.10 and higher and
--   haskell-mpfr when compiling with ghc 7.8.
module AERN2.MP.Float.Type

-- | Multiple-precision floating-point type based on MPFR via hmpfr.
type MPFloat = MPFR
setPrecisionUp :: Precision -> MPFloat -> MPFloat
setPrecisionDown :: Precision -> MPFloat -> MPFloat
p2mpfrPrec :: Precision -> Precision
instance AERN2.MP.Precision.HasPrecision AERN2.MP.Float.Type.MPFloat
instance AERN2.MP.Precision.CanSetPrecision AERN2.MP.Float.Type.MPFloat


-- | Integer-based arbitrary precision floating point numbers. Currently
--   not used. It is much slower than to MPFR.
module AERN2.MP.Float.Native

-- | <tt>MPFloat n e p</tt> represents the number <tt>n*2^e</tt>. Moreover,
--   <tt>|n| &lt; 2^p</tt> and either $n=0$ or <tt>n</tt> is odd.
data MPFloat
MPFloat :: !Integer -> !Integer -> !Precision -> MPFloat
[mpFloat_integer] :: MPFloat -> !Integer
[mpFloat_exponent] :: MPFloat -> !Integer
[mpFloat_precision] :: MPFloat -> !Precision
makeNOdd :: MPFloat -> MPFloat
countZeroBits :: Integer -> Integer
zero :: MPFloat
one :: MPFloat
getPrec :: MPFloat -> Precision
data RoundMode
Up :: RoundMode
Down :: RoundMode
reverseRoundMode :: RoundMode -> RoundMode
set :: RoundMode -> Precision -> MPFloat -> MPFloat
type UnaryOp = RoundMode -> Precision -> MPFloat -> MPFloat
type BinaryOp = RoundMode -> Precision -> MPFloat -> MPFloat -> MPFloat
neg :: UnaryOp
add :: BinaryOp
sub :: BinaryOp
mul :: BinaryOp
div :: BinaryOp
toDouble :: RoundMode -> MPFloat -> Double
toDoubleNear :: MPFloat -> Double
toRational :: MPFloat -> Rational
fromIntegerA :: RoundMode -> Precision -> Integer -> MPFloat
fromRationalA :: RoundMode -> Precision -> Rational -> MPFloat
data Precision
instance GHC.Classes.Eq AERN2.MP.Float.Native.RoundMode
instance GHC.Show.Show AERN2.MP.Float.Native.RoundMode
instance GHC.Classes.Eq AERN2.MP.Float.Native.MPFloat
instance GHC.Classes.Ord AERN2.MP.Float.Native.MPFloat
instance AERN2.Norm.HasNorm AERN2.MP.Float.Native.MPFloat
instance GHC.Show.Show AERN2.MP.Float.Native.MPFloat


-- | Arbitrary precision floating-point numbers with up/down-rounded
--   operations.
--   
--   Currently, we use hmpfr when compiling with ghc 7.10 and higher and
--   haskell-mpfr when compiling with ghc 7.8.
module AERN2.MP.Float.Arithmetic
addUp :: MPFloat -> MPFloat -> MPFloat
addDown :: MPFloat -> MPFloat -> MPFloat
subUp :: MPFloat -> MPFloat -> MPFloat
subDown :: MPFloat -> MPFloat -> MPFloat
mulUp :: MPFloat -> MPFloat -> MPFloat
mulDown :: MPFloat -> MPFloat -> MPFloat
divUp :: MPFloat -> MPFloat -> MPFloat
divDown :: MPFloat -> MPFloat -> MPFloat
recipUp :: MPFloat -> MPFloat
recipDown :: MPFloat -> MPFloat
piUp :: Precision -> MPFloat
piDown :: Precision -> MPFloat
cosUp :: MPFloat -> MPFloat
cosDown :: MPFloat -> MPFloat
sinUp :: MPFloat -> MPFloat
sinDown :: MPFloat -> MPFloat
sqrtUp :: MPFloat -> MPFloat
sqrtDown :: MPFloat -> MPFloat
expUp :: MPFloat -> MPFloat
expDown :: MPFloat -> MPFloat
logUp :: MPFloat -> MPFloat
logDown :: MPFloat -> MPFloat
instance Numeric.MixedTypes.Bool.CanNeg AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.MinMaxAbs.CanAbs AERN2.MP.Float.Type.MPFloat


-- | Conversions and comparisons of arbitrary precision floating point
--   numbers
--   
--   Currently, we use hmpfr when compiling with ghc 7.10 and higher and
--   haskell-mpfr when compiling with ghc 7.8.
module AERN2.MP.Float.Conversions
toDoubleUp :: MPFloat -> Double
toDoubleDown :: MPFloat -> Double
type CanBeMPFloat t = ConvertibleExactly t MPFloat
mpFloat :: (CanBeMPFloat t) => t -> MPFloat
fromIntegerUp :: Precision -> Integer -> MPFloat
fromIntegerDown :: Precision -> Integer -> MPFloat
fromRationalUp :: Precision -> Rational -> MPFloat
fromRationalDown :: Precision -> Rational -> MPFloat
instance AERN2.Norm.HasNorm AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Round.CanRound AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Float.Type.MPFloat GHC.Real.Rational
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int AERN2.MP.Float.Type.MPFloat
instance Data.Convertible.Base.Convertible AERN2.MP.Float.Type.MPFloat GHC.Types.Double
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Float.Type.MPFloat AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Float.Type.MPFloat GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Float.Type.MPFloat GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Float.Type.MPFloat GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Eq.CanTestZero AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Float.Type.MPFloat AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Float.Type.MPFloat GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Float.Type.MPFloat GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Float.Type.MPFloat GHC.Real.Rational
instance Numeric.MixedTypes.Ord.CanTestPosNeg AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Float.Type.MPFloat AERN2.MP.Float.Type.MPFloat


-- | Infix operators for up/down-rounded floating-point numbers
module AERN2.MP.Float.Operators
(+^) :: MPFloat -> MPFloat -> MPFloat
infixl 6 +^
(-^) :: MPFloat -> MPFloat -> MPFloat
infixl 6 -^
(*^) :: MPFloat -> MPFloat -> MPFloat
infixl 7 *^
(/^) :: MPFloat -> MPFloat -> MPFloat
infixl 7 /^
(+.) :: MPFloat -> MPFloat -> MPFloat
infixl 6 +.
(-.) :: MPFloat -> MPFloat -> MPFloat
infixl 6 -.
(*.) :: MPFloat -> MPFloat -> MPFloat
infixl 7 *.
(/.) :: MPFloat -> MPFloat -> MPFloat
infixl 7 /.


-- | Special constants NaN, infinity etc
module AERN2.MP.Float.Constants
zero :: MPFloat
one :: MPFloat
nan :: MPFloat
infinity :: MPFloat
instance Numeric.MixedTypes.Eq.CanTestFinite AERN2.MP.Float.Type.MPFloat


-- | Tests for operations on arbitrary precision floats.
--   
--   To run the tests using stack, execute:
--   
--   <pre>
--   stack test aern2-mp --test-arguments "-a 1000 -m MPFloat"
--   
--   </pre>
module AERN2.MP.Float.Tests
specMPFloat :: Spec

-- | A runtime representative of type <tt>MPFloat</tt>. Used for
--   specialising polymorphic tests to concrete types.
tMPFloat :: T MPFloat
(=~=) :: MPFloat -> MPFloat -> Property
infix 4 =~=

-- | Assert equality of two MPFloat's with tolerance <tt>1/2^p</tt>.
approxEqual :: Integer -> MPFloat -> MPFloat -> Bool

-- | Assert equality of two MPFloat's with tolerance derived from the size
--   and precision of the given intermediate values. When the assertion
--   fails, report the given values using the given names.
approxEqualWithArgs :: [(MPFloat, String)] -> MPFloat -> MPFloat -> Property
frequencyElements :: ConvertibleExactly t Int => [(t, a)] -> Gen a
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.MP.Float.Type.MPFloat


-- | Arbitrary precision floating-point numbers with up/down-rounded
--   operations.
--   
--   Currently, we use hmpfr when compiling with ghc 7.10 and higher and
--   haskell-mpfr when compiling with ghc 7.8.
module AERN2.MP.Float

-- | Computes an upper bound to the distance <tt>|x - y|</tt> of <tt>x</tt>
--   and <tt>y</tt>.
distUp :: MPFloat -> MPFloat -> MPFloat

-- | Computes a lower bound to the distance <tt>|x - y|</tt> of <tt>x</tt>
--   and <tt>y</tt>.
distDown :: MPFloat -> MPFloat -> MPFloat
avgUp :: MPFloat -> MPFloat -> MPFloat
avgDown :: MPFloat -> MPFloat -> MPFloat


-- | A type for roughly measuring the accuracy of an enclosure.
module AERN2.MP.Accuracy

-- | A non-negative Double value to serve as an error bound. Arithmetic is
--   rounded towards +infinity.
data Accuracy
NoInformation :: Accuracy
Exact :: Accuracy
bits :: (ConvertibleExactly t Accuracy) => t -> Accuracy
fromAccuracy :: Accuracy -> Integer
normLog2Accuracy :: NormLog -> Accuracy
class HasAccuracy a
getAccuracy :: HasAccuracy a => a -> Accuracy

-- | Return accuracy, except when the element is Exact, return its nominal
--   Precision dressed as Accuracy. This function is useful when we have a
--   convergent sequence where all elements happen to be actually equal to
--   the limit and we need the property that the sequence elements keep
--   improving.
getFiniteAccuracy :: (HasAccuracy t, HasPrecision t) => t -> Accuracy
class CanReduceSizeUsingAccuracyGuide t
reduceSizeUsingAccuracyGuide :: CanReduceSizeUsingAccuracyGuide t => Accuracy -> t -> t
specCanReduceSizeUsingAccuracyGuide :: (CanReduceSizeUsingAccuracyGuide t, HasEqCertainly t t, Arbitrary t, Show t) => (T t) -> Spec
iterateUntilAccurate :: (HasAccuracy t) => Accuracy -> (Precision -> Maybe t) -> [(Precision, Maybe t)]
convergentList2CauchySeq :: (HasAccuracy t) => [t] -> (Accuracy -> t)
seqByPrecision2CauchySeq :: (HasAccuracy t) => (Precision -> t) -> (Accuracy -> t)

-- | Change the precision so that it is at least as high as the supplied
--   accuracy (assuming the accuracy is finite).
setPrecisionAtLeastAccuracy :: (CanSetPrecision t) => Accuracy -> t -> t

-- | An unsafe approximation of an enclosure or exact value, useful mainly
--   for showing something brief and readable to humans.
class HasApproximate t where type Approximate t where {
    type family Approximate t;
}
getApproximate :: HasApproximate t => Accuracy -> t -> (Approximate t)
instance GHC.Classes.Ord AERN2.MP.Accuracy.Accuracy
instance GHC.Classes.Eq AERN2.MP.Accuracy.Accuracy
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.MP.Accuracy.Accuracy
instance GHC.Enum.Enum AERN2.MP.Accuracy.Accuracy
instance GHC.Enum.Bounded AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Precision.Precision AERN2.MP.Accuracy.Accuracy
instance GHC.Show.Show AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Accuracy.Accuracy AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Accuracy.Accuracy AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Accuracy.Accuracy AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Integer.Type.Integer
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Types.Int
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Bool.CanNeg AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Accuracy.Accuracy AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Accuracy.Accuracy AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Accuracy.Accuracy GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer AERN2.MP.Accuracy.Accuracy
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Accuracy.Accuracy GHC.Integer.Type.Integer
instance AERN2.MP.Accuracy.HasAccuracy a => AERN2.MP.Accuracy.HasAccuracy (Numeric.CatchingExceptions.Type.CatchingNumExceptions a)
instance AERN2.MP.Accuracy.HasAccuracy GHC.Types.Int
instance AERN2.MP.Accuracy.HasAccuracy GHC.Integer.Type.Integer
instance AERN2.MP.Accuracy.HasAccuracy GHC.Real.Rational
instance AERN2.MP.Accuracy.HasAccuracy t => AERN2.MP.Accuracy.HasAccuracy (Data.Complex.Complex t)
instance AERN2.MP.Accuracy.HasAccuracy t => AERN2.MP.Accuracy.HasAccuracy [t]


-- | Arbitrary precision floating-point numbers with exact ring operations.
--   
--   Currently, we use hmpfr when compiling with ghc 7.10 and higher and
--   haskell-mpfr when compiling with ghc 7.8.
module AERN2.MP.Dyadic

-- | Exact dyadic type based on MPFloat.
data Dyadic
type HasDyadics t = ConvertibleExactly Dyadic t
type CanBeDyadic t = ConvertibleExactly t Dyadic
dyadic :: (CanBeDyadic t) => t -> Dyadic
specDyadic :: Spec

-- | A runtime representative of type <tt>Dyadic</tt>. Used for
--   specialising polymorphic tests to concrete types.
tDyadic :: T Dyadic
instance AERN2.Norm.HasNorm AERN2.MP.Dyadic.Dyadic
instance AERN2.MP.Precision.HasPrecision AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Round.CanRound AERN2.MP.Dyadic.Dyadic
instance GHC.Classes.Ord AERN2.MP.Dyadic.Dyadic
instance GHC.Classes.Eq AERN2.MP.Dyadic.Dyadic
instance AERN2.MP.Accuracy.HasAccuracy AERN2.MP.Dyadic.Dyadic
instance GHC.Show.Show AERN2.MP.Dyadic.Dyadic
instance GHC.Read.Read AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Dyadic.Dyadic AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Float.Type.MPFloat AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Data.Convertible.Base.Convertible AERN2.MP.Dyadic.Dyadic GHC.Types.Double
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Eq.CanTestZero AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance Numeric.MixedTypes.Ord.CanTestPosNeg AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Eq.CanTestInteger AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Bool.CanNeg AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.MinMaxAbs.CanAbs AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric t AERN2.MP.Dyadic.Dyadic, GHC.Show.Show (Numeric.MixedTypes.MinMaxAbs.MinMaxType t AERN2.MP.Dyadic.Dyadic), Numeric.CatchingExceptions.Type.CanTestValid (Numeric.MixedTypes.MinMaxAbs.MinMaxType t AERN2.MP.Dyadic.Dyadic)) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric (Numeric.CatchingExceptions.Type.CatchingNumExceptions t) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic t, GHC.Show.Show (Numeric.MixedTypes.MinMaxAbs.MinMaxType AERN2.MP.Dyadic.Dyadic t), Numeric.CatchingExceptions.Type.CanTestValid (Numeric.MixedTypes.MinMaxAbs.MinMaxType AERN2.MP.Dyadic.Dyadic t)) => Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic (Numeric.CatchingExceptions.Type.CatchingNumExceptions t)
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric t AERN2.MP.Dyadic.Dyadic, GHC.Show.Show (Numeric.MixedTypes.AddSub.AddType t AERN2.MP.Dyadic.Dyadic), Numeric.CatchingExceptions.Type.CanTestValid (Numeric.MixedTypes.AddSub.AddType t AERN2.MP.Dyadic.Dyadic)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric (Numeric.CatchingExceptions.Type.CatchingNumExceptions t) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic t, GHC.Show.Show (Numeric.MixedTypes.AddSub.AddType AERN2.MP.Dyadic.Dyadic t), Numeric.CatchingExceptions.Type.CanTestValid (Numeric.MixedTypes.AddSub.AddType AERN2.MP.Dyadic.Dyadic t)) => Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic (Numeric.CatchingExceptions.Type.CatchingNumExceptions t)
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance (Numeric.MixedTypes.AddSub.CanSub t AERN2.MP.Dyadic.Dyadic, GHC.Show.Show (Numeric.MixedTypes.AddSub.SubType t AERN2.MP.Dyadic.Dyadic), Numeric.CatchingExceptions.Type.CanTestValid (Numeric.MixedTypes.AddSub.SubType t AERN2.MP.Dyadic.Dyadic)) => Numeric.MixedTypes.AddSub.CanSub (Numeric.CatchingExceptions.Type.CatchingNumExceptions t) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic t, GHC.Show.Show (Numeric.MixedTypes.AddSub.SubType AERN2.MP.Dyadic.Dyadic t), Numeric.CatchingExceptions.Type.CanTestValid (Numeric.MixedTypes.AddSub.SubType AERN2.MP.Dyadic.Dyadic t)) => Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic (Numeric.CatchingExceptions.Type.CatchingNumExceptions t)
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric t AERN2.MP.Dyadic.Dyadic, GHC.Show.Show (Numeric.MixedTypes.Ring.MulType t AERN2.MP.Dyadic.Dyadic), Numeric.CatchingExceptions.Type.CanTestValid (Numeric.MixedTypes.Ring.MulType t AERN2.MP.Dyadic.Dyadic)) => Numeric.MixedTypes.Ring.CanMulAsymmetric (Numeric.CatchingExceptions.Type.CatchingNumExceptions t) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic t, GHC.Show.Show (Numeric.MixedTypes.Ring.MulType AERN2.MP.Dyadic.Dyadic t), Numeric.CatchingExceptions.Type.CanTestValid (Numeric.MixedTypes.Ring.MulType AERN2.MP.Dyadic.Dyadic t)) => Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic (Numeric.CatchingExceptions.Type.CatchingNumExceptions t)
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance (Numeric.MixedTypes.Field.CanDiv t AERN2.MP.Dyadic.Dyadic, GHC.Show.Show (Numeric.MixedTypes.Field.DivType t AERN2.MP.Dyadic.Dyadic), Numeric.CatchingExceptions.Type.CanTestValid (Numeric.MixedTypes.Field.DivType t AERN2.MP.Dyadic.Dyadic)) => Numeric.MixedTypes.Field.CanDiv (Numeric.CatchingExceptions.Type.CatchingNumExceptions t) AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Int AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic GHC.Types.Int
instance Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic GHC.Real.Rational
instance (Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic t, Numeric.MixedTypes.Eq.CanTestZero t, GHC.Show.Show (Numeric.MixedTypes.Field.DivType AERN2.MP.Dyadic.Dyadic t), Numeric.CatchingExceptions.Type.CanTestValid (Numeric.MixedTypes.Field.DivType AERN2.MP.Dyadic.Dyadic t)) => Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic (Numeric.CatchingExceptions.Type.CatchingNumExceptions t)
instance (Numeric.MixedTypes.Ring.CanPow t AERN2.MP.Dyadic.Dyadic, Numeric.MixedTypes.Bool.CanNegSameType t, GHC.Show.Show t, Numeric.MixedTypes.Ord.CanTestPosNeg t, GHC.Show.Show (Numeric.MixedTypes.Ring.PowType t AERN2.MP.Dyadic.Dyadic), Numeric.CatchingExceptions.Type.CanTestValid (Numeric.MixedTypes.Ring.PowType t AERN2.MP.Dyadic.Dyadic)) => Numeric.MixedTypes.Ring.CanPow (Numeric.CatchingExceptions.Type.CatchingNumExceptions t) AERN2.MP.Dyadic.Dyadic
instance (Numeric.MixedTypes.Ring.CanPow AERN2.MP.Dyadic.Dyadic t, GHC.Show.Show t, Numeric.MixedTypes.Ord.CanTestPosNeg t, Numeric.MixedTypes.Eq.CanTestInteger t, GHC.Show.Show (Numeric.MixedTypes.Ring.PowType AERN2.MP.Dyadic.Dyadic t), Numeric.CatchingExceptions.Type.CanTestValid (Numeric.MixedTypes.Ring.PowType AERN2.MP.Dyadic.Dyadic t)) => Numeric.MixedTypes.Ring.CanPow AERN2.MP.Dyadic.Dyadic (Numeric.CatchingExceptions.Type.CatchingNumExceptions t)
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.MP.Dyadic.Dyadic


-- | Fixed precision non-negative up-rounded floating-point numbers.
--   
--   Currently using a fixed-precision MPFloat.
module AERN2.MP.ErrorBound

-- | A non-negative Double value to serve as an error bound. Arithmetic is
--   rounded towards +infinity.
data ErrorBound
type CanBeErrorBound t = Convertible t ErrorBound
errorBound :: (CanBeErrorBound t) => t -> ErrorBound
absMP :: MPFloat -> ErrorBound
subMP :: MPFloat -> MPFloat -> ErrorBound
instance GHC.Classes.Ord AERN2.MP.ErrorBound.ErrorBound
instance GHC.Classes.Eq AERN2.MP.ErrorBound.ErrorBound
instance GHC.Show.Show AERN2.MP.ErrorBound.ErrorBound
instance AERN2.MP.Accuracy.HasAccuracy AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.ErrorBound.ErrorBound AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.ErrorBound.ErrorBound AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.ErrorBound.ErrorBound GHC.Real.Rational
instance Data.Convertible.Base.Convertible GHC.Real.Rational AERN2.MP.ErrorBound.ErrorBound
instance Data.Convertible.Base.Convertible AERN2.MP.Float.Type.MPFloat AERN2.MP.ErrorBound.ErrorBound
instance Data.Convertible.Base.Convertible GHC.Integer.Type.Integer AERN2.MP.ErrorBound.ErrorBound
instance Data.Convertible.Base.Convertible GHC.Types.Int AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.ErrorBound.ErrorBound AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.ErrorBound.ErrorBound AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Float.Type.MPFloat AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Real.Rational
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.ErrorBound.ErrorBound AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.ErrorBound.ErrorBound AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.ErrorBound.ErrorBound AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Float.Type.MPFloat AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.ErrorBound.ErrorBound AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.ErrorBound.ErrorBound AERN2.MP.Float.Type.MPFloat
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Float.Type.MPFloat AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.ErrorBound.ErrorBound GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.ErrorBound.ErrorBound GHC.Integer.Type.Integer
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.MP.ErrorBound.ErrorBound


-- | Enclosure classes and operations.
module AERN2.MP.Enclosure
class IsBall t where type CentreType t centreAsBall = fst . centreAsBallAndRadius radius = snd . centreAsBallAndRadius makeExactCentre v = updateRadius (+ r) c where (c, r) = centreAsBallAndRadius v where {
    type family CentreType t;
}
centre :: IsBall t => t -> CentreType t
centreAsBallAndRadius :: IsBall t => t -> (t, ErrorBound)
centreAsBall :: IsBall t => t -> t
radius :: IsBall t => t -> ErrorBound
updateRadius :: IsBall t => (ErrorBound -> ErrorBound) -> (t -> t)

-- | When the radius of the ball is implicitly contributed to by
--   imprecision in the centre (eg if the centre is a polynomial with
--   inexact coefficients), move all that imprecision to the explicit
--   radius, making the centre exact. This may lose some information, but
--   as a ball is equivalent to the original. For MPBall this function is
--   pointless because it is equivalent to the identity.
makeExactCentre :: (IsBall t, IsBall t) => t -> t
class IsInterval i e
fromEndpoints :: IsInterval i e => e -> e -> i
endpoints :: IsInterval i e => i -> (e, e)

-- | Computes a *monotone* ball function <tt>f</tt> on intervals using the
--   interval endpoints.
intervalFunctionByEndpoints :: (IsInterval t t, HasEqCertainly t t) => (t -> t) -> (t -> t)

-- | Computes a *monotone* ball function <tt>f</tt> on intervals using the
--   interval endpoints.
intervalFunctionByEndpointsUpDown :: (IsInterval t e) => (e -> e) -> (e -> e) -> (t -> t)
class CanTestContains dom e

-- | Test if <tt>e</tt> is inside <tt>dom</tt>.
contains :: CanTestContains dom e => dom -> e -> Bool
class CanMapInside dom e

-- | Return some value contained in <tt>dom</tt>. The returned value does
--   not have to equal the given <tt>e</tt> even if <tt>e</tt> is already
--   inside <tt>dom</tt>. All elements of <tt>dom</tt> should be covered
--   with roughly the same probability when calling this function for
--   evenly distributed <tt>e</tt>'s.
--   
--   This function is intended mainly for generating values inside
--   <tt>dom</tt> for randomised tests.
mapInside :: CanMapInside dom e => dom -> e -> e
specCanMapInside :: (CanMapInside d e, CanTestContains d e, Arbitrary d, Arbitrary e, Show d, Show e) => T d -> T e -> Spec


-- | Arbitrary precision dyadic balls
module AERN2.MP.Ball.Type
data MPBall
MPBall :: {-# UNPACK #-} !MPFloat -> {-# UNPACK #-} !ErrorBound -> MPBall
[ball_value] :: MPBall -> {-# UNPACK #-} !MPFloat
[ball_error] :: MPBall -> {-# UNPACK #-} !ErrorBound
type CanBeMPBall t = ConvertibleExactly t MPBall
mpBall :: (CanBeMPBall t) => t -> MPBall
type CanBeMPBallP t = ConvertibleWithPrecision t MPBall
mpBallP :: (CanBeMPBallP t) => Precision -> t -> MPBall

-- | Reduce the precision of the ball centre if the accuracy of the ball is
--   poor.
--   
--   More precisely, reduce the precision of the centre so that the ulp is
--   approximately (radius / 1024), unless the ulp is already lower than
--   this.
reducePrecionIfInaccurate :: MPBall -> MPBall
endpointsMP :: MPBall -> (MPFloat, MPFloat)
fromEndpointsMP :: MPFloat -> MPFloat -> MPBall
instance AERN2.MP.Enclosure.CanTestContains AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance AERN2.MP.Enclosure.CanTestContains AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance AERN2.MP.Enclosure.CanTestContains AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance AERN2.MP.Enclosure.CanTestContains AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance AERN2.MP.Enclosure.IsInterval AERN2.MP.Ball.Type.MPBall AERN2.MP.Float.Type.MPFloat
instance AERN2.MP.Enclosure.IsInterval AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Enclosure.IsBall AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Accuracy.HasAccuracy AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Accuracy.CanReduceSizeUsingAccuracyGuide AERN2.MP.Ball.Type.MPBall
instance AERN2.Norm.HasNorm AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Accuracy.HasApproximate AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Precision.HasPrecision AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Precision.CanSetPrecision AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Bool.CanNeg AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.MinMaxAbs.CanAbs AERN2.MP.Ball.Type.MPBall
instance GHC.Generics.Generic AERN2.MP.Ball.Type.MPBall
instance GHC.Show.Show AERN2.MP.Ball.Type.MPBall
instance Numeric.CatchingExceptions.Type.CanTestValid AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.CanTestFinite AERN2.MP.Ball.Type.MPBall
instance AERN2.Normalize.CanNormalize AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Enclosure.CanTestContains AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall


-- | Conversions of arbitrary precision dyadic balls
module AERN2.MP.Ball.Conversions
integerBounds :: HasIntegerBounds t => t -> (Integer, Integer)
instance Numeric.MixedTypes.Round.HasIntegerBounds AERN2.MP.Ball.Type.MPBall
instance Data.Convertible.Base.Convertible AERN2.MP.Ball.Type.MPBall AERN2.MP.ErrorBound.ErrorBound
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Literals.ConvertibleExactly AERN2.MP.ErrorBound.ErrorBound AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Literals.ConvertibleExactly (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer) AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Literals.ConvertibleExactly GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Literals.ConvertibleExactly (GHC.Types.Int, GHC.Types.Int) AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Precision.ConvertibleWithPrecision GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Precision.ConvertibleWithPrecision GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Precision.ConvertibleWithPrecision GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance AERN2.MP.Precision.ConvertibleWithPrecision (GHC.Real.Rational, GHC.Real.Rational) AERN2.MP.Ball.Type.MPBall


-- | Comparisons of arbitrary precision dyadic balls
module AERN2.MP.Ball.Comparisons

-- | Reduce the precision of the ball centre if the accuracy of the ball is
--   poor.
--   
--   More precisely, reduce the precision of the centre so that the ulp is
--   approximately (radius / 1024), unless the ulp is already lower than
--   this.
reducePrecionIfInaccurate :: MPBall -> MPBall
intersect :: MPBall -> MPBall -> MPBall

-- | Computes an *increasing* ball fucntion <tt>f</tt> from *exact* MPFR
--   operations.
byEndpointsMP :: (MPFloat -> MPFloat -> MPFloat) -> (MPBall -> MPBall -> MPBall)
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.Eq.HasEqAsymmetric GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Eq.HasEqAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.Ord.HasOrderAsymmetric GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.CanTestZero AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ord.CanTestPosNeg AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Eq.CanTestInteger AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.MinMaxAbs.CanMinMaxAsymmetric GHC.Real.Rational AERN2.MP.Ball.Type.MPBall


-- | Field operations on arbitrary precision dyadic balls
module AERN2.MP.Ball.Field
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanAddAsymmetric GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.AddSub.CanSub GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance Numeric.MixedTypes.AddSub.CanSub GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.AddSub.CanSub GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.AddSub.CanSub AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanMulAsymmetric AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.Ring.CanMulAsymmetric GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall GHC.Types.Int
instance Numeric.MixedTypes.Field.CanDiv GHC.Types.Int AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Field.CanDiv GHC.Integer.Type.Integer AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Dyadic.Dyadic AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Field.CanDiv AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.Field.CanDiv GHC.Real.Rational AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall GHC.Integer.Type.Integer
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall GHC.Types.Int


-- | Elementary operations on arbitrary precision dyadic balls
module AERN2.MP.Ball.Elementary
piBallP :: Precision -> MPBall

-- | Computes a real function <tt>f</tt> from correctly rounded
--   MPFR-approximations and a number <tt>lip</tt> which is a Lipschitz
--   constant for <tt>f</tt>, i.e. <tt>|f(x) - f(y)| &lt;= lip * |x -
--   y|</tt> for all <tt>x</tt>,<tt>y</tt>.
fromApproxWithLipschitz :: (MPFloat -> MPFloat) -> (MPFloat -> MPFloat) -> MPFloat -> (MPBall -> MPBall)
instance Numeric.MixedTypes.Elementary.CanSinCos AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Elementary.CanExp AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Elementary.CanLog AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.Elementary.CanSqrt AERN2.MP.Ball.Type.MPBall
instance GHC.Num.Num AERN2.MP.Ball.Type.MPBall
instance GHC.Classes.Eq AERN2.MP.Ball.Type.MPBall
instance GHC.Classes.Ord AERN2.MP.Ball.Type.MPBall
instance GHC.Real.Fractional AERN2.MP.Ball.Type.MPBall
instance GHC.Float.Floating AERN2.MP.Ball.Type.MPBall


-- | Arbitrary precision ball arithmetic
module AERN2.MP.Ball
data MPBall
MPBall :: {-# UNPACK #-} !MPFloat -> {-# UNPACK #-} !ErrorBound -> MPBall
[ball_value] :: MPBall -> {-# UNPACK #-} !MPFloat
[ball_error] :: MPBall -> {-# UNPACK #-} !ErrorBound
type CanBeMPBall t = ConvertibleExactly t MPBall
mpBall :: (CanBeMPBall t) => t -> MPBall
type CanBeMPBallP t = ConvertibleWithPrecision t MPBall
mpBallP :: (CanBeMPBallP t) => Precision -> t -> MPBall

-- | Reduce the precision of the ball centre if the accuracy of the ball is
--   poor.
--   
--   More precisely, reduce the precision of the centre so that the ulp is
--   approximately (radius / 1024), unless the ulp is already lower than
--   this.
reducePrecionIfInaccurate :: MPBall -> MPBall
intersect :: MPBall -> MPBall -> MPBall
piBallP :: Precision -> MPBall

-- | Computes an *increasing* ball fucntion <tt>f</tt> from *exact* MPFR
--   operations.
byEndpointsMP :: (MPFloat -> MPFloat -> MPFloat) -> (MPBall -> MPBall -> MPBall)

-- | Computes a real function <tt>f</tt> from correctly rounded
--   MPFR-approximations and a number <tt>lip</tt> which is a Lipschitz
--   constant for <tt>f</tt>, i.e. <tt>|f(x) - f(y)| &lt;= lip * |x -
--   y|</tt> for all <tt>x</tt>,<tt>y</tt>.
fromApproxWithLipschitz :: (MPFloat -> MPFloat) -> (MPFloat -> MPFloat) -> MPFloat -> (MPBall -> MPBall)


-- | Elementary operations on arbitrary precision dyadic balls defined
--   using only ball field operations. This is useful in the absence of
--   MPFR float-level elementary operations.
module AERN2.MP.Ball.ElementaryFromField
piBallP :: Precision -> MPBall
instance Numeric.MixedTypes.Elementary.CanExp AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Elementary.CanLog AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall AERN2.MP.Dyadic.Dyadic
instance Numeric.MixedTypes.Ring.CanPow AERN2.MP.Ball.Type.MPBall GHC.Real.Rational
instance Numeric.MixedTypes.Elementary.CanSqrt AERN2.MP.Ball.Type.MPBall
instance Numeric.MixedTypes.Elementary.CanSinCos AERN2.MP.Ball.Type.MPBall
instance GHC.Num.Num AERN2.MP.Ball.Type.MPBall
instance GHC.Classes.Eq AERN2.MP.Ball.Type.MPBall
instance GHC.Classes.Ord AERN2.MP.Ball.Type.MPBall
instance GHC.Real.Fractional AERN2.MP.Ball.Type.MPBall
instance GHC.Float.Floating AERN2.MP.Ball.Type.MPBall


-- | Tests for operations on arbitrary precision balls.
--   
--   To run the tests using stack, execute:
--   
--   <pre>
--   stack test aern2-mp --test-arguments "-a 1000 -m MPBall"
--   
--   </pre>
module AERN2.MP.Ball.Tests
specMPBall :: Spec

-- | A runtime representative of type <tt>MPBall</tt>. Used for
--   specialising polymorphic tests to concrete types.
tMPBall :: T MPBall
instance Test.QuickCheck.Arbitrary.Arbitrary AERN2.MP.Ball.Type.MPBall


-- | Multiple-precision ball arithmetic
module AERN2.MP
data MPBall
MPBall :: {-# UNPACK #-} !MPFloat -> {-# UNPACK #-} !ErrorBound -> MPBall
[ball_value] :: MPBall -> {-# UNPACK #-} !MPFloat
[ball_error] :: MPBall -> {-# UNPACK #-} !ErrorBound
type CanBeMPBall t = ConvertibleExactly t MPBall
mpBall :: (CanBeMPBall t) => t -> MPBall
type CanBeMPBallP t = ConvertibleWithPrecision t MPBall
mpBallP :: (CanBeMPBallP t) => Precision -> t -> MPBall
